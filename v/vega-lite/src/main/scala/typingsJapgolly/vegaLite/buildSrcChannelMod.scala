package typingsJapgolly.vegaLite

import typingsJapgolly.vegaLite.buildSrcCompileScaleTypeMod.RangeType
import typingsJapgolly.vegaLite.buildSrcMarkMod.Mark
import typingsJapgolly.vegaLite.vegaLiteInts.`1`
import typingsJapgolly.vegaLite.vegaLiteStrings.always
import typingsJapgolly.vegaLite.vegaLiteStrings.angle
import typingsJapgolly.vegaLite.vegaLiteStrings.binned
import typingsJapgolly.vegaLite.vegaLiteStrings.color
import typingsJapgolly.vegaLite.vegaLiteStrings.column
import typingsJapgolly.vegaLite.vegaLiteStrings.description
import typingsJapgolly.vegaLite.vegaLiteStrings.detail
import typingsJapgolly.vegaLite.vegaLiteStrings.endAngle
import typingsJapgolly.vegaLite.vegaLiteStrings.facet
import typingsJapgolly.vegaLite.vegaLiteStrings.fill
import typingsJapgolly.vegaLite.vegaLiteStrings.fillOpacity
import typingsJapgolly.vegaLite.vegaLiteStrings.height
import typingsJapgolly.vegaLite.vegaLiteStrings.href
import typingsJapgolly.vegaLite.vegaLiteStrings.innerRadius
import typingsJapgolly.vegaLite.vegaLiteStrings.key
import typingsJapgolly.vegaLite.vegaLiteStrings.latitude
import typingsJapgolly.vegaLite.vegaLiteStrings.latitude2
import typingsJapgolly.vegaLite.vegaLiteStrings.longitude
import typingsJapgolly.vegaLite.vegaLiteStrings.longitude2
import typingsJapgolly.vegaLite.vegaLiteStrings.opacity
import typingsJapgolly.vegaLite.vegaLiteStrings.order
import typingsJapgolly.vegaLite.vegaLiteStrings.outerRadius
import typingsJapgolly.vegaLite.vegaLiteStrings.radius
import typingsJapgolly.vegaLite.vegaLiteStrings.radius2
import typingsJapgolly.vegaLite.vegaLiteStrings.radius2Offset
import typingsJapgolly.vegaLite.vegaLiteStrings.radiusOffset
import typingsJapgolly.vegaLite.vegaLiteStrings.row
import typingsJapgolly.vegaLite.vegaLiteStrings.shape
import typingsJapgolly.vegaLite.vegaLiteStrings.size
import typingsJapgolly.vegaLite.vegaLiteStrings.startAngle
import typingsJapgolly.vegaLite.vegaLiteStrings.stroke
import typingsJapgolly.vegaLite.vegaLiteStrings.strokeDash
import typingsJapgolly.vegaLite.vegaLiteStrings.strokeOpacity
import typingsJapgolly.vegaLite.vegaLiteStrings.strokeWidth
import typingsJapgolly.vegaLite.vegaLiteStrings.text
import typingsJapgolly.vegaLite.vegaLiteStrings.theta
import typingsJapgolly.vegaLite.vegaLiteStrings.theta2
import typingsJapgolly.vegaLite.vegaLiteStrings.theta2Offset
import typingsJapgolly.vegaLite.vegaLiteStrings.thetaOffset
import typingsJapgolly.vegaLite.vegaLiteStrings.tooltip
import typingsJapgolly.vegaLite.vegaLiteStrings.url
import typingsJapgolly.vegaLite.vegaLiteStrings.width
import typingsJapgolly.vegaLite.vegaLiteStrings.x
import typingsJapgolly.vegaLite.vegaLiteStrings.x2
import typingsJapgolly.vegaLite.vegaLiteStrings.x2Offset
import typingsJapgolly.vegaLite.vegaLiteStrings.xOffset
import typingsJapgolly.vegaLite.vegaLiteStrings.y
import typingsJapgolly.vegaLite.vegaLiteStrings.y2
import typingsJapgolly.vegaLite.vegaLiteStrings.y2Offset
import typingsJapgolly.vegaLite.vegaLiteStrings.yOffset
import org.scalablytyped.runtime.StObject
import scala.scalajs.js
import scala.scalajs.js.annotation.{JSGlobalScope, JSGlobal, JSImport, JSName, JSBracketAccess}

object buildSrcChannelMod {
  
  @JSImport("vega-lite/build/src/channel", JSImport.Namespace)
  @js.native
  val ^ : js.Any = js.native
  
  @JSImport("vega-lite/build/src/channel", "ANGLE")
  @js.native
  val ANGLE: angle = js.native
  
  @JSImport("vega-lite/build/src/channel", "CHANNELS")
  @js.native
  val CHANNELS: js.Array[
    fill | detail | key | url | color | fillOpacity | opacity | order | stroke | strokeOpacity | strokeWidth | text | size | description | x | x2 | y | y2 | strokeDash | tooltip | angle | shape | radius | theta | facet | href | theta2 | radius2 | xOffset | yOffset | longitude | latitude | longitude2 | latitude2 | row | column
  ] = js.native
  
  @JSImport("vega-lite/build/src/channel", "COLOR")
  @js.native
  val COLOR: color = js.native
  
  @JSImport("vega-lite/build/src/channel", "COLUMN")
  @js.native
  val COLUMN: column = js.native
  
  @JSImport("vega-lite/build/src/channel", "DESCRIPTION")
  @js.native
  val DESCRIPTION: description = js.native
  
  @JSImport("vega-lite/build/src/channel", "DETAIL")
  @js.native
  val DETAIL: detail = js.native
  
  @JSImport("vega-lite/build/src/channel", "FACET")
  @js.native
  val FACET: facet = js.native
  
  @JSImport("vega-lite/build/src/channel", "FACET_CHANNELS")
  @js.native
  val FACET_CHANNELS: js.Array[
    /* keyof vega-lite.vega-lite/build/src/spec/facet.EncodingFacetMapping<any, any> */ facet | row | column
  ] = js.native
  
  @JSImport("vega-lite/build/src/channel", "FILL")
  @js.native
  val FILL: fill = js.native
  
  @JSImport("vega-lite/build/src/channel", "FILLOPACITY")
  @js.native
  val FILLOPACITY: fillOpacity = js.native
  
  @JSImport("vega-lite/build/src/channel", "GEOPOSITION_CHANNELS")
  @js.native
  val GEOPOSITION_CHANNELS: js.Array[longitude | latitude | longitude2 | latitude2] = js.native
  
  @JSImport("vega-lite/build/src/channel", "HREF")
  @js.native
  val HREF: href = js.native
  
  @JSImport("vega-lite/build/src/channel", "KEY")
  @js.native
  val KEY: key = js.native
  
  @JSImport("vega-lite/build/src/channel", "LATITUDE")
  @js.native
  val LATITUDE: latitude = js.native
  
  @JSImport("vega-lite/build/src/channel", "LATITUDE2")
  @js.native
  val LATITUDE2: latitude2 = js.native
  
  @JSImport("vega-lite/build/src/channel", "LONGITUDE")
  @js.native
  val LONGITUDE: longitude = js.native
  
  @JSImport("vega-lite/build/src/channel", "LONGITUDE2")
  @js.native
  val LONGITUDE2: longitude2 = js.native
  
  @JSImport("vega-lite/build/src/channel", "NONPOSITION_CHANNELS")
  @js.native
  val NONPOSITION_CHANNELS: js.Array[
    fill | detail | key | url | color | fillOpacity | opacity | order | stroke | strokeOpacity | strokeWidth | text | size | description | strokeDash | tooltip | angle | shape | href
  ] = js.native
  
  @JSImport("vega-lite/build/src/channel", "NONPOSITION_SCALE_CHANNELS")
  @js.native
  val NONPOSITION_SCALE_CHANNELS: js.Array[
    fill | color | fillOpacity | opacity | stroke | strokeOpacity | strokeWidth | size | strokeDash | angle | shape
  ] = js.native
  
  @JSImport("vega-lite/build/src/channel", "OFFSET_SCALE_CHANNELS")
  @js.native
  val OFFSET_SCALE_CHANNELS: js.Array[xOffset | yOffset] = js.native
  
  @JSImport("vega-lite/build/src/channel", "OPACITY")
  @js.native
  val OPACITY: opacity = js.native
  
  @JSImport("vega-lite/build/src/channel", "ORDER")
  @js.native
  val ORDER: order = js.native
  
  @JSImport("vega-lite/build/src/channel", "POLAR_POSITION_SCALE_CHANNELS")
  @js.native
  val POLAR_POSITION_SCALE_CHANNELS: js.Array[radius | theta] = js.native
  
  object POLAR_POSITION_SCALE_CHANNEL_INDEX {
    
    @JSImport("vega-lite/build/src/channel", "POLAR_POSITION_SCALE_CHANNEL_INDEX.radius")
    @js.native
    val radius: `1` = js.native
    
    @JSImport("vega-lite/build/src/channel", "POLAR_POSITION_SCALE_CHANNEL_INDEX.theta")
    @js.native
    val theta: `1` = js.native
  }
  
  @JSImport("vega-lite/build/src/channel", "POSITION_SCALE_CHANNELS")
  @js.native
  val POSITION_SCALE_CHANNELS: js.Array[x | y] = js.native
  
  @JSImport("vega-lite/build/src/channel", "RADIUS")
  @js.native
  val RADIUS: radius = js.native
  
  @JSImport("vega-lite/build/src/channel", "RADIUS2")
  @js.native
  val RADIUS2: radius2 = js.native
  
  @JSImport("vega-lite/build/src/channel", "ROW")
  @js.native
  val ROW: row = js.native
  
  @JSImport("vega-lite/build/src/channel", "SCALE_CHANNELS")
  @js.native
  val SCALE_CHANNELS: js.Array[
    fill | color | fillOpacity | opacity | stroke | strokeOpacity | strokeWidth | size | x | y | strokeDash | angle | shape | radius | theta | xOffset | yOffset
  ] = js.native
  
  @JSImport("vega-lite/build/src/channel", "SECONDARY_RANGE_CHANNEL")
  @js.native
  val SECONDARY_RANGE_CHANNEL: js.Array[SecondaryRangeChannel] = js.native
  
  @JSImport("vega-lite/build/src/channel", "SHAPE")
  @js.native
  val SHAPE: shape = js.native
  
  @JSImport("vega-lite/build/src/channel", "SINGLE_DEF_CHANNELS")
  @js.native
  val SINGLE_DEF_CHANNELS: js.Array[
    fill | key | url | color | fillOpacity | opacity | stroke | strokeOpacity | strokeWidth | text | size | description | x | x2 | y | y2 | strokeDash | angle | shape | radius | theta | facet | href | theta2 | radius2 | xOffset | yOffset | longitude | latitude | longitude2 | latitude2 | row | column
  ] = js.native
  
  @JSImport("vega-lite/build/src/channel", "SINGLE_DEF_UNIT_CHANNELS")
  @js.native
  val SINGLE_DEF_UNIT_CHANNELS: js.Array[
    fill | key | url | color | fillOpacity | opacity | stroke | strokeOpacity | strokeWidth | text | size | description | x | x2 | y | y2 | strokeDash | angle | shape | radius | theta | href | theta2 | radius2 | xOffset | yOffset | longitude | latitude | longitude2 | latitude2
  ] = js.native
  
  @JSImport("vega-lite/build/src/channel", "SIZE")
  @js.native
  val SIZE: size = js.native
  
  @JSImport("vega-lite/build/src/channel", "STROKE")
  @js.native
  val STROKE: stroke = js.native
  
  @JSImport("vega-lite/build/src/channel", "STROKEDASH")
  @js.native
  val STROKEDASH: strokeDash = js.native
  
  @JSImport("vega-lite/build/src/channel", "STROKEOPACITY")
  @js.native
  val STROKEOPACITY: strokeOpacity = js.native
  
  @JSImport("vega-lite/build/src/channel", "STROKEWIDTH")
  @js.native
  val STROKEWIDTH: strokeWidth = js.native
  
  @JSImport("vega-lite/build/src/channel", "TEXT")
  @js.native
  val TEXT: text = js.native
  
  @JSImport("vega-lite/build/src/channel", "THETA")
  @js.native
  val THETA: theta = js.native
  
  @JSImport("vega-lite/build/src/channel", "THETA2")
  @js.native
  val THETA2: theta2 = js.native
  
  @JSImport("vega-lite/build/src/channel", "TOOLTIP")
  @js.native
  val TOOLTIP: tooltip = js.native
  
  @JSImport("vega-lite/build/src/channel", "UNIT_CHANNELS")
  @js.native
  val UNIT_CHANNELS: js.Array[
    /* keyof vega-lite.vega-lite/build/src/encoding.Encoding<any> */ x | y | xOffset | yOffset | x2 | y2 | longitude | latitude | longitude2 | latitude2 | theta | theta2 | radius | radius2 | color | fill | stroke | opacity | fillOpacity | strokeOpacity | strokeWidth | strokeDash | size | angle | shape | detail | key | text | tooltip | href | url | description | order
  ] = js.native
  
  @JSImport("vega-lite/build/src/channel", "URL")
  @js.native
  val URL: url = js.native
  
  @JSImport("vega-lite/build/src/channel", "X")
  @js.native
  val X: x = js.native
  
  @JSImport("vega-lite/build/src/channel", "X2")
  @js.native
  val X2: x2 = js.native
  
  @JSImport("vega-lite/build/src/channel", "XOFFSET")
  @js.native
  val XOFFSET: xOffset = js.native
  
  @JSImport("vega-lite/build/src/channel", "Y")
  @js.native
  val Y: y = js.native
  
  @JSImport("vega-lite/build/src/channel", "Y2")
  @js.native
  val Y2: y2 = js.native
  
  @JSImport("vega-lite/build/src/channel", "YOFFSET")
  @js.native
  val YOFFSET: yOffset = js.native
  
  inline def getMainChannelFromOffsetChannel(channel: OffsetScaleChannel): PositionScaleChannel = ^.asInstanceOf[js.Dynamic].applyDynamic("getMainChannelFromOffsetChannel")(channel.asInstanceOf[js.Any]).asInstanceOf[PositionScaleChannel]
  
  inline def getMainRangeChannel_angle(channel: angle): MainChannelOf[angle] = ^.asInstanceOf[js.Dynamic].applyDynamic("getMainRangeChannel")(channel.asInstanceOf[js.Any]).asInstanceOf[MainChannelOf[angle]]
  
  inline def getMainRangeChannel_color(channel: color): MainChannelOf[color] = ^.asInstanceOf[js.Dynamic].applyDynamic("getMainRangeChannel")(channel.asInstanceOf[js.Any]).asInstanceOf[MainChannelOf[color]]
  
  inline def getMainRangeChannel_column(channel: column): MainChannelOf[column] = ^.asInstanceOf[js.Dynamic].applyDynamic("getMainRangeChannel")(channel.asInstanceOf[js.Any]).asInstanceOf[MainChannelOf[column]]
  
  inline def getMainRangeChannel_description(channel: description): MainChannelOf[description] = ^.asInstanceOf[js.Dynamic].applyDynamic("getMainRangeChannel")(channel.asInstanceOf[js.Any]).asInstanceOf[MainChannelOf[description]]
  
  inline def getMainRangeChannel_detail(channel: detail): MainChannelOf[detail] = ^.asInstanceOf[js.Dynamic].applyDynamic("getMainRangeChannel")(channel.asInstanceOf[js.Any]).asInstanceOf[MainChannelOf[detail]]
  
  inline def getMainRangeChannel_facet(channel: facet): MainChannelOf[facet] = ^.asInstanceOf[js.Dynamic].applyDynamic("getMainRangeChannel")(channel.asInstanceOf[js.Any]).asInstanceOf[MainChannelOf[facet]]
  
  inline def getMainRangeChannel_fill(channel: fill): MainChannelOf[fill] = ^.asInstanceOf[js.Dynamic].applyDynamic("getMainRangeChannel")(channel.asInstanceOf[js.Any]).asInstanceOf[MainChannelOf[fill]]
  
  inline def getMainRangeChannel_fillOpacity(channel: fillOpacity): MainChannelOf[fillOpacity] = ^.asInstanceOf[js.Dynamic].applyDynamic("getMainRangeChannel")(channel.asInstanceOf[js.Any]).asInstanceOf[MainChannelOf[fillOpacity]]
  
  inline def getMainRangeChannel_href(channel: href): MainChannelOf[href] = ^.asInstanceOf[js.Dynamic].applyDynamic("getMainRangeChannel")(channel.asInstanceOf[js.Any]).asInstanceOf[MainChannelOf[href]]
  
  inline def getMainRangeChannel_key(channel: key): MainChannelOf[key] = ^.asInstanceOf[js.Dynamic].applyDynamic("getMainRangeChannel")(channel.asInstanceOf[js.Any]).asInstanceOf[MainChannelOf[key]]
  
  inline def getMainRangeChannel_latitude(channel: latitude): MainChannelOf[latitude] = ^.asInstanceOf[js.Dynamic].applyDynamic("getMainRangeChannel")(channel.asInstanceOf[js.Any]).asInstanceOf[MainChannelOf[latitude]]
  
  inline def getMainRangeChannel_latitude2(channel: latitude2): MainChannelOf[latitude2] = ^.asInstanceOf[js.Dynamic].applyDynamic("getMainRangeChannel")(channel.asInstanceOf[js.Any]).asInstanceOf[MainChannelOf[latitude2]]
  
  inline def getMainRangeChannel_longitude(channel: longitude): MainChannelOf[longitude] = ^.asInstanceOf[js.Dynamic].applyDynamic("getMainRangeChannel")(channel.asInstanceOf[js.Any]).asInstanceOf[MainChannelOf[longitude]]
  
  inline def getMainRangeChannel_longitude2(channel: longitude2): MainChannelOf[longitude2] = ^.asInstanceOf[js.Dynamic].applyDynamic("getMainRangeChannel")(channel.asInstanceOf[js.Any]).asInstanceOf[MainChannelOf[longitude2]]
  
  inline def getMainRangeChannel_opacity(channel: opacity): MainChannelOf[opacity] = ^.asInstanceOf[js.Dynamic].applyDynamic("getMainRangeChannel")(channel.asInstanceOf[js.Any]).asInstanceOf[MainChannelOf[opacity]]
  
  inline def getMainRangeChannel_order(channel: order): MainChannelOf[order] = ^.asInstanceOf[js.Dynamic].applyDynamic("getMainRangeChannel")(channel.asInstanceOf[js.Any]).asInstanceOf[MainChannelOf[order]]
  
  inline def getMainRangeChannel_radius(channel: radius): MainChannelOf[radius] = ^.asInstanceOf[js.Dynamic].applyDynamic("getMainRangeChannel")(channel.asInstanceOf[js.Any]).asInstanceOf[MainChannelOf[radius]]
  
  inline def getMainRangeChannel_radius2(channel: radius2): MainChannelOf[radius2] = ^.asInstanceOf[js.Dynamic].applyDynamic("getMainRangeChannel")(channel.asInstanceOf[js.Any]).asInstanceOf[MainChannelOf[radius2]]
  
  inline def getMainRangeChannel_row(channel: row): MainChannelOf[row] = ^.asInstanceOf[js.Dynamic].applyDynamic("getMainRangeChannel")(channel.asInstanceOf[js.Any]).asInstanceOf[MainChannelOf[row]]
  
  inline def getMainRangeChannel_shape(channel: shape): MainChannelOf[shape] = ^.asInstanceOf[js.Dynamic].applyDynamic("getMainRangeChannel")(channel.asInstanceOf[js.Any]).asInstanceOf[MainChannelOf[shape]]
  
  inline def getMainRangeChannel_size(channel: size): MainChannelOf[size] = ^.asInstanceOf[js.Dynamic].applyDynamic("getMainRangeChannel")(channel.asInstanceOf[js.Any]).asInstanceOf[MainChannelOf[size]]
  
  inline def getMainRangeChannel_stroke(channel: stroke): MainChannelOf[stroke] = ^.asInstanceOf[js.Dynamic].applyDynamic("getMainRangeChannel")(channel.asInstanceOf[js.Any]).asInstanceOf[MainChannelOf[stroke]]
  
  inline def getMainRangeChannel_strokeDash(channel: strokeDash): MainChannelOf[strokeDash] = ^.asInstanceOf[js.Dynamic].applyDynamic("getMainRangeChannel")(channel.asInstanceOf[js.Any]).asInstanceOf[MainChannelOf[strokeDash]]
  
  inline def getMainRangeChannel_strokeOpacity(channel: strokeOpacity): MainChannelOf[strokeOpacity] = ^.asInstanceOf[js.Dynamic].applyDynamic("getMainRangeChannel")(channel.asInstanceOf[js.Any]).asInstanceOf[MainChannelOf[strokeOpacity]]
  
  inline def getMainRangeChannel_strokeWidth(channel: strokeWidth): MainChannelOf[strokeWidth] = ^.asInstanceOf[js.Dynamic].applyDynamic("getMainRangeChannel")(channel.asInstanceOf[js.Any]).asInstanceOf[MainChannelOf[strokeWidth]]
  
  inline def getMainRangeChannel_text(channel: text): MainChannelOf[text] = ^.asInstanceOf[js.Dynamic].applyDynamic("getMainRangeChannel")(channel.asInstanceOf[js.Any]).asInstanceOf[MainChannelOf[text]]
  
  inline def getMainRangeChannel_theta(channel: theta): MainChannelOf[theta] = ^.asInstanceOf[js.Dynamic].applyDynamic("getMainRangeChannel")(channel.asInstanceOf[js.Any]).asInstanceOf[MainChannelOf[theta]]
  
  inline def getMainRangeChannel_theta2(channel: theta2): MainChannelOf[theta2] = ^.asInstanceOf[js.Dynamic].applyDynamic("getMainRangeChannel")(channel.asInstanceOf[js.Any]).asInstanceOf[MainChannelOf[theta2]]
  
  inline def getMainRangeChannel_tooltip(channel: tooltip): MainChannelOf[tooltip] = ^.asInstanceOf[js.Dynamic].applyDynamic("getMainRangeChannel")(channel.asInstanceOf[js.Any]).asInstanceOf[MainChannelOf[tooltip]]
  
  inline def getMainRangeChannel_url(channel: url): MainChannelOf[url] = ^.asInstanceOf[js.Dynamic].applyDynamic("getMainRangeChannel")(channel.asInstanceOf[js.Any]).asInstanceOf[MainChannelOf[url]]
  
  inline def getMainRangeChannel_x(channel: x): MainChannelOf[x] = ^.asInstanceOf[js.Dynamic].applyDynamic("getMainRangeChannel")(channel.asInstanceOf[js.Any]).asInstanceOf[MainChannelOf[x]]
  
  inline def getMainRangeChannel_x2(channel: x2): MainChannelOf[x2] = ^.asInstanceOf[js.Dynamic].applyDynamic("getMainRangeChannel")(channel.asInstanceOf[js.Any]).asInstanceOf[MainChannelOf[x2]]
  
  inline def getMainRangeChannel_xOffset(channel: xOffset): MainChannelOf[xOffset] = ^.asInstanceOf[js.Dynamic].applyDynamic("getMainRangeChannel")(channel.asInstanceOf[js.Any]).asInstanceOf[MainChannelOf[xOffset]]
  
  inline def getMainRangeChannel_y(channel: y): MainChannelOf[y] = ^.asInstanceOf[js.Dynamic].applyDynamic("getMainRangeChannel")(channel.asInstanceOf[js.Any]).asInstanceOf[MainChannelOf[y]]
  
  inline def getMainRangeChannel_y2(channel: y2): MainChannelOf[y2] = ^.asInstanceOf[js.Dynamic].applyDynamic("getMainRangeChannel")(channel.asInstanceOf[js.Any]).asInstanceOf[MainChannelOf[y2]]
  
  inline def getMainRangeChannel_yOffset(channel: yOffset): MainChannelOf[yOffset] = ^.asInstanceOf[js.Dynamic].applyDynamic("getMainRangeChannel")(channel.asInstanceOf[js.Any]).asInstanceOf[MainChannelOf[yOffset]]
  
  inline def getOffsetChannel(channel: Channel): xOffset | yOffset | x2Offset | y2Offset | thetaOffset | radiusOffset | theta2Offset | radius2Offset = ^.asInstanceOf[js.Dynamic].applyDynamic("getOffsetChannel")(channel.asInstanceOf[js.Any]).asInstanceOf[xOffset | yOffset | x2Offset | y2Offset | thetaOffset | radiusOffset | theta2Offset | radius2Offset]
  
  inline def getOffsetScaleChannel(channel: Channel): OffsetScaleChannel = ^.asInstanceOf[js.Dynamic].applyDynamic("getOffsetScaleChannel")(channel.asInstanceOf[js.Any]).asInstanceOf[OffsetScaleChannel]
  
  inline def getPositionChannelFromLatLong(channel: GeoPositionChannel): PositionChannel = ^.asInstanceOf[js.Dynamic].applyDynamic("getPositionChannelFromLatLong")(channel.asInstanceOf[js.Any]).asInstanceOf[PositionChannel]
  
  inline def getPositionScaleChannel(sizeType: width | height): PositionScaleChannel = ^.asInstanceOf[js.Dynamic].applyDynamic("getPositionScaleChannel")(sizeType.asInstanceOf[js.Any]).asInstanceOf[PositionScaleChannel]
  
  inline def getSecondaryRangeChannel_angle(channel: angle): js.UndefOr[SecondaryChannelOf[angle]] = ^.asInstanceOf[js.Dynamic].applyDynamic("getSecondaryRangeChannel")(channel.asInstanceOf[js.Any]).asInstanceOf[js.UndefOr[SecondaryChannelOf[angle]]]
  
  inline def getSecondaryRangeChannel_color(channel: color): js.UndefOr[SecondaryChannelOf[color]] = ^.asInstanceOf[js.Dynamic].applyDynamic("getSecondaryRangeChannel")(channel.asInstanceOf[js.Any]).asInstanceOf[js.UndefOr[SecondaryChannelOf[color]]]
  
  inline def getSecondaryRangeChannel_description(channel: description): js.UndefOr[SecondaryChannelOf[description]] = ^.asInstanceOf[js.Dynamic].applyDynamic("getSecondaryRangeChannel")(channel.asInstanceOf[js.Any]).asInstanceOf[js.UndefOr[SecondaryChannelOf[description]]]
  
  inline def getSecondaryRangeChannel_detail(channel: detail): js.UndefOr[SecondaryChannelOf[detail]] = ^.asInstanceOf[js.Dynamic].applyDynamic("getSecondaryRangeChannel")(channel.asInstanceOf[js.Any]).asInstanceOf[js.UndefOr[SecondaryChannelOf[detail]]]
  
  inline def getSecondaryRangeChannel_fill(channel: fill): js.UndefOr[SecondaryChannelOf[fill]] = ^.asInstanceOf[js.Dynamic].applyDynamic("getSecondaryRangeChannel")(channel.asInstanceOf[js.Any]).asInstanceOf[js.UndefOr[SecondaryChannelOf[fill]]]
  
  inline def getSecondaryRangeChannel_fillOpacity(channel: fillOpacity): js.UndefOr[SecondaryChannelOf[fillOpacity]] = ^.asInstanceOf[js.Dynamic].applyDynamic("getSecondaryRangeChannel")(channel.asInstanceOf[js.Any]).asInstanceOf[js.UndefOr[SecondaryChannelOf[fillOpacity]]]
  
  inline def getSecondaryRangeChannel_href(channel: href): js.UndefOr[SecondaryChannelOf[href]] = ^.asInstanceOf[js.Dynamic].applyDynamic("getSecondaryRangeChannel")(channel.asInstanceOf[js.Any]).asInstanceOf[js.UndefOr[SecondaryChannelOf[href]]]
  
  inline def getSecondaryRangeChannel_key(channel: key): js.UndefOr[SecondaryChannelOf[key]] = ^.asInstanceOf[js.Dynamic].applyDynamic("getSecondaryRangeChannel")(channel.asInstanceOf[js.Any]).asInstanceOf[js.UndefOr[SecondaryChannelOf[key]]]
  
  inline def getSecondaryRangeChannel_latitude(channel: latitude): js.UndefOr[SecondaryChannelOf[latitude]] = ^.asInstanceOf[js.Dynamic].applyDynamic("getSecondaryRangeChannel")(channel.asInstanceOf[js.Any]).asInstanceOf[js.UndefOr[SecondaryChannelOf[latitude]]]
  
  inline def getSecondaryRangeChannel_latitude2(channel: latitude2): js.UndefOr[SecondaryChannelOf[latitude2]] = ^.asInstanceOf[js.Dynamic].applyDynamic("getSecondaryRangeChannel")(channel.asInstanceOf[js.Any]).asInstanceOf[js.UndefOr[SecondaryChannelOf[latitude2]]]
  
  inline def getSecondaryRangeChannel_longitude(channel: longitude): js.UndefOr[SecondaryChannelOf[longitude]] = ^.asInstanceOf[js.Dynamic].applyDynamic("getSecondaryRangeChannel")(channel.asInstanceOf[js.Any]).asInstanceOf[js.UndefOr[SecondaryChannelOf[longitude]]]
  
  inline def getSecondaryRangeChannel_longitude2(channel: longitude2): js.UndefOr[SecondaryChannelOf[longitude2]] = ^.asInstanceOf[js.Dynamic].applyDynamic("getSecondaryRangeChannel")(channel.asInstanceOf[js.Any]).asInstanceOf[js.UndefOr[SecondaryChannelOf[longitude2]]]
  
  inline def getSecondaryRangeChannel_opacity(channel: opacity): js.UndefOr[SecondaryChannelOf[opacity]] = ^.asInstanceOf[js.Dynamic].applyDynamic("getSecondaryRangeChannel")(channel.asInstanceOf[js.Any]).asInstanceOf[js.UndefOr[SecondaryChannelOf[opacity]]]
  
  inline def getSecondaryRangeChannel_order(channel: order): js.UndefOr[SecondaryChannelOf[order]] = ^.asInstanceOf[js.Dynamic].applyDynamic("getSecondaryRangeChannel")(channel.asInstanceOf[js.Any]).asInstanceOf[js.UndefOr[SecondaryChannelOf[order]]]
  
  inline def getSecondaryRangeChannel_radius(channel: radius): js.UndefOr[SecondaryChannelOf[radius]] = ^.asInstanceOf[js.Dynamic].applyDynamic("getSecondaryRangeChannel")(channel.asInstanceOf[js.Any]).asInstanceOf[js.UndefOr[SecondaryChannelOf[radius]]]
  
  inline def getSecondaryRangeChannel_radius2(channel: radius2): js.UndefOr[SecondaryChannelOf[radius2]] = ^.asInstanceOf[js.Dynamic].applyDynamic("getSecondaryRangeChannel")(channel.asInstanceOf[js.Any]).asInstanceOf[js.UndefOr[SecondaryChannelOf[radius2]]]
  
  inline def getSecondaryRangeChannel_shape(channel: shape): js.UndefOr[SecondaryChannelOf[shape]] = ^.asInstanceOf[js.Dynamic].applyDynamic("getSecondaryRangeChannel")(channel.asInstanceOf[js.Any]).asInstanceOf[js.UndefOr[SecondaryChannelOf[shape]]]
  
  inline def getSecondaryRangeChannel_size(channel: size): js.UndefOr[SecondaryChannelOf[size]] = ^.asInstanceOf[js.Dynamic].applyDynamic("getSecondaryRangeChannel")(channel.asInstanceOf[js.Any]).asInstanceOf[js.UndefOr[SecondaryChannelOf[size]]]
  
  inline def getSecondaryRangeChannel_stroke(channel: stroke): js.UndefOr[SecondaryChannelOf[stroke]] = ^.asInstanceOf[js.Dynamic].applyDynamic("getSecondaryRangeChannel")(channel.asInstanceOf[js.Any]).asInstanceOf[js.UndefOr[SecondaryChannelOf[stroke]]]
  
  inline def getSecondaryRangeChannel_strokeDash(channel: strokeDash): js.UndefOr[SecondaryChannelOf[strokeDash]] = ^.asInstanceOf[js.Dynamic].applyDynamic("getSecondaryRangeChannel")(channel.asInstanceOf[js.Any]).asInstanceOf[js.UndefOr[SecondaryChannelOf[strokeDash]]]
  
  inline def getSecondaryRangeChannel_strokeOpacity(channel: strokeOpacity): js.UndefOr[SecondaryChannelOf[strokeOpacity]] = ^.asInstanceOf[js.Dynamic].applyDynamic("getSecondaryRangeChannel")(channel.asInstanceOf[js.Any]).asInstanceOf[js.UndefOr[SecondaryChannelOf[strokeOpacity]]]
  
  inline def getSecondaryRangeChannel_strokeWidth(channel: strokeWidth): js.UndefOr[SecondaryChannelOf[strokeWidth]] = ^.asInstanceOf[js.Dynamic].applyDynamic("getSecondaryRangeChannel")(channel.asInstanceOf[js.Any]).asInstanceOf[js.UndefOr[SecondaryChannelOf[strokeWidth]]]
  
  inline def getSecondaryRangeChannel_text(channel: text): js.UndefOr[SecondaryChannelOf[text]] = ^.asInstanceOf[js.Dynamic].applyDynamic("getSecondaryRangeChannel")(channel.asInstanceOf[js.Any]).asInstanceOf[js.UndefOr[SecondaryChannelOf[text]]]
  
  inline def getSecondaryRangeChannel_theta(channel: theta): js.UndefOr[SecondaryChannelOf[theta]] = ^.asInstanceOf[js.Dynamic].applyDynamic("getSecondaryRangeChannel")(channel.asInstanceOf[js.Any]).asInstanceOf[js.UndefOr[SecondaryChannelOf[theta]]]
  
  inline def getSecondaryRangeChannel_theta2(channel: theta2): js.UndefOr[SecondaryChannelOf[theta2]] = ^.asInstanceOf[js.Dynamic].applyDynamic("getSecondaryRangeChannel")(channel.asInstanceOf[js.Any]).asInstanceOf[js.UndefOr[SecondaryChannelOf[theta2]]]
  
  inline def getSecondaryRangeChannel_tooltip(channel: tooltip): js.UndefOr[SecondaryChannelOf[tooltip]] = ^.asInstanceOf[js.Dynamic].applyDynamic("getSecondaryRangeChannel")(channel.asInstanceOf[js.Any]).asInstanceOf[js.UndefOr[SecondaryChannelOf[tooltip]]]
  
  inline def getSecondaryRangeChannel_url(channel: url): js.UndefOr[SecondaryChannelOf[url]] = ^.asInstanceOf[js.Dynamic].applyDynamic("getSecondaryRangeChannel")(channel.asInstanceOf[js.Any]).asInstanceOf[js.UndefOr[SecondaryChannelOf[url]]]
  
  inline def getSecondaryRangeChannel_x(channel: x): js.UndefOr[SecondaryChannelOf[x]] = ^.asInstanceOf[js.Dynamic].applyDynamic("getSecondaryRangeChannel")(channel.asInstanceOf[js.Any]).asInstanceOf[js.UndefOr[SecondaryChannelOf[x]]]
  
  inline def getSecondaryRangeChannel_x2(channel: x2): js.UndefOr[SecondaryChannelOf[x2]] = ^.asInstanceOf[js.Dynamic].applyDynamic("getSecondaryRangeChannel")(channel.asInstanceOf[js.Any]).asInstanceOf[js.UndefOr[SecondaryChannelOf[x2]]]
  
  inline def getSecondaryRangeChannel_xOffset(channel: xOffset): js.UndefOr[SecondaryChannelOf[xOffset]] = ^.asInstanceOf[js.Dynamic].applyDynamic("getSecondaryRangeChannel")(channel.asInstanceOf[js.Any]).asInstanceOf[js.UndefOr[SecondaryChannelOf[xOffset]]]
  
  inline def getSecondaryRangeChannel_y(channel: y): js.UndefOr[SecondaryChannelOf[y]] = ^.asInstanceOf[js.Dynamic].applyDynamic("getSecondaryRangeChannel")(channel.asInstanceOf[js.Any]).asInstanceOf[js.UndefOr[SecondaryChannelOf[y]]]
  
  inline def getSecondaryRangeChannel_y2(channel: y2): js.UndefOr[SecondaryChannelOf[y2]] = ^.asInstanceOf[js.Dynamic].applyDynamic("getSecondaryRangeChannel")(channel.asInstanceOf[js.Any]).asInstanceOf[js.UndefOr[SecondaryChannelOf[y2]]]
  
  inline def getSecondaryRangeChannel_yOffset(channel: yOffset): js.UndefOr[SecondaryChannelOf[yOffset]] = ^.asInstanceOf[js.Dynamic].applyDynamic("getSecondaryRangeChannel")(channel.asInstanceOf[js.Any]).asInstanceOf[js.UndefOr[SecondaryChannelOf[yOffset]]]
  
  inline def getSizeChannel(channel: Channel): js.UndefOr[width | height] = ^.asInstanceOf[js.Dynamic].applyDynamic("getSizeChannel")(channel.asInstanceOf[js.Any]).asInstanceOf[js.UndefOr[width | height]]
  inline def getSizeChannel(channel: PositionChannel): width | height = ^.asInstanceOf[js.Dynamic].applyDynamic("getSizeChannel")(channel.asInstanceOf[js.Any]).asInstanceOf[width | height]
  
  inline def getVgPositionChannel(channel: PolarPositionChannel): x | x2 | y | y2 | innerRadius | outerRadius | startAngle | endAngle = ^.asInstanceOf[js.Dynamic].applyDynamic("getVgPositionChannel")(channel.asInstanceOf[js.Any]).asInstanceOf[x | x2 | y | y2 | innerRadius | outerRadius | startAngle | endAngle]
  inline def getVgPositionChannel(channel: PositionChannel): x | x2 | y | y2 | innerRadius | outerRadius | startAngle | endAngle = ^.asInstanceOf[js.Dynamic].applyDynamic("getVgPositionChannel")(channel.asInstanceOf[js.Any]).asInstanceOf[x | x2 | y | y2 | innerRadius | outerRadius | startAngle | endAngle]
  
  inline def isChannel(str: String): /* is vega-lite.vega-lite/build/src/channel.Channel */ Boolean = ^.asInstanceOf[js.Dynamic].applyDynamic("isChannel")(str.asInstanceOf[js.Any]).asInstanceOf[/* is vega-lite.vega-lite/build/src/channel.Channel */ Boolean]
  
  inline def isColorChannel(channel: Channel): /* is vega-lite.vega-lite/build/src/channel.ColorChannel */ Boolean = ^.asInstanceOf[js.Dynamic].applyDynamic("isColorChannel")(channel.asInstanceOf[js.Any]).asInstanceOf[/* is vega-lite.vega-lite/build/src/channel.ColorChannel */ Boolean]
  
  inline def isGeoPositionChannel(c: Channel): /* is vega-lite.vega-lite/build/src/channel.GeoPositionChannel */ Boolean = ^.asInstanceOf[js.Dynamic].applyDynamic("isGeoPositionChannel")(c.asInstanceOf[js.Any]).asInstanceOf[/* is vega-lite.vega-lite/build/src/channel.GeoPositionChannel */ Boolean]
  
  inline def isNonPositionScaleChannel(channel: Channel): /* is vega-lite.vega-lite/build/src/channel.NonPositionScaleChannel */ Boolean = ^.asInstanceOf[js.Dynamic].applyDynamic("isNonPositionScaleChannel")(channel.asInstanceOf[js.Any]).asInstanceOf[/* is vega-lite.vega-lite/build/src/channel.NonPositionScaleChannel */ Boolean]
  
  inline def isPolarPositionChannel(c: Channel): /* is vega-lite.vega-lite/build/src/channel.PolarPositionChannel */ Boolean = ^.asInstanceOf[js.Dynamic].applyDynamic("isPolarPositionChannel")(c.asInstanceOf[js.Any]).asInstanceOf[/* is vega-lite.vega-lite/build/src/channel.PolarPositionChannel */ Boolean]
  
  inline def isScaleChannel(channel: Channel): /* is vega-lite.vega-lite/build/src/channel.ScaleChannel */ Boolean = ^.asInstanceOf[js.Dynamic].applyDynamic("isScaleChannel")(channel.asInstanceOf[js.Any]).asInstanceOf[/* is vega-lite.vega-lite/build/src/channel.ScaleChannel */ Boolean]
  
  inline def isSecondaryRangeChannel(c: ExtendedChannel): /* is vega-lite.vega-lite/build/src/channel.SecondaryRangeChannel */ Boolean = ^.asInstanceOf[js.Dynamic].applyDynamic("isSecondaryRangeChannel")(c.asInstanceOf[js.Any]).asInstanceOf[/* is vega-lite.vega-lite/build/src/channel.SecondaryRangeChannel */ Boolean]
  
  inline def isSingleDefUnitChannel(str: String): /* is vega-lite.vega-lite/build/src/channel.SingleDefUnitChannel */ Boolean = ^.asInstanceOf[js.Dynamic].applyDynamic("isSingleDefUnitChannel")(str.asInstanceOf[js.Any]).asInstanceOf[/* is vega-lite.vega-lite/build/src/channel.SingleDefUnitChannel */ Boolean]
  
  inline def isXorY(channel: ExtendedChannel): /* is vega-lite.vega-lite/build/src/channel.PositionScaleChannel */ Boolean = ^.asInstanceOf[js.Dynamic].applyDynamic("isXorY")(channel.asInstanceOf[js.Any]).asInstanceOf[/* is vega-lite.vega-lite/build/src/channel.PositionScaleChannel */ Boolean]
  
  inline def isXorYOffset(channel: Channel): /* is vega-lite.vega-lite/build/src/channel.OffsetScaleChannel */ Boolean = ^.asInstanceOf[js.Dynamic].applyDynamic("isXorYOffset")(channel.asInstanceOf[js.Any]).asInstanceOf[/* is vega-lite.vega-lite/build/src/channel.OffsetScaleChannel */ Boolean]
  
  inline def rangeType(channel: ExtendedChannel): RangeType = ^.asInstanceOf[js.Dynamic].applyDynamic("rangeType")(channel.asInstanceOf[js.Any]).asInstanceOf[RangeType]
  
  inline def supportLegend(channel: NonPositionScaleChannel): Boolean = ^.asInstanceOf[js.Dynamic].applyDynamic("supportLegend")(channel.asInstanceOf[js.Any]).asInstanceOf[Boolean]
  
  inline def supportMark(channel: ExtendedChannel, mark: Mark): always | binned = (^.asInstanceOf[js.Dynamic].applyDynamic("supportMark")(channel.asInstanceOf[js.Any], mark.asInstanceOf[js.Any])).asInstanceOf[always | binned]
  
  /* keyof vega-lite.vega-lite/build/src/encoding.Encoding<any> */ /* Rewritten from type alias, can be one of: 
    - typingsJapgolly.vegaLite.vegaLiteStrings.x
    - typingsJapgolly.vegaLite.vegaLiteStrings.y
    - typingsJapgolly.vegaLite.vegaLiteStrings.xOffset
    - typingsJapgolly.vegaLite.vegaLiteStrings.yOffset
    - typingsJapgolly.vegaLite.vegaLiteStrings.x2
    - typingsJapgolly.vegaLite.vegaLiteStrings.y2
    - typingsJapgolly.vegaLite.vegaLiteStrings.longitude
    - typingsJapgolly.vegaLite.vegaLiteStrings.latitude
    - typingsJapgolly.vegaLite.vegaLiteStrings.longitude2
    - typingsJapgolly.vegaLite.vegaLiteStrings.latitude2
    - typingsJapgolly.vegaLite.vegaLiteStrings.theta
    - typingsJapgolly.vegaLite.vegaLiteStrings.theta2
    - typingsJapgolly.vegaLite.vegaLiteStrings.radius
    - typingsJapgolly.vegaLite.vegaLiteStrings.radius2
    - typingsJapgolly.vegaLite.vegaLiteStrings.color
    - typingsJapgolly.vegaLite.vegaLiteStrings.fill
    - typingsJapgolly.vegaLite.vegaLiteStrings.stroke
    - typingsJapgolly.vegaLite.vegaLiteStrings.opacity
    - typingsJapgolly.vegaLite.vegaLiteStrings.fillOpacity
    - typingsJapgolly.vegaLite.vegaLiteStrings.strokeOpacity
    - typingsJapgolly.vegaLite.vegaLiteStrings.strokeWidth
    - typingsJapgolly.vegaLite.vegaLiteStrings.strokeDash
    - typingsJapgolly.vegaLite.vegaLiteStrings.size
    - typingsJapgolly.vegaLite.vegaLiteStrings.angle
    - typingsJapgolly.vegaLite.vegaLiteStrings.shape
    - typingsJapgolly.vegaLite.vegaLiteStrings.detail
    - typingsJapgolly.vegaLite.vegaLiteStrings.key
    - typingsJapgolly.vegaLite.vegaLiteStrings.text
    - typingsJapgolly.vegaLite.vegaLiteStrings.tooltip
    - typingsJapgolly.vegaLite.vegaLiteStrings.href
    - typingsJapgolly.vegaLite.vegaLiteStrings.url
    - typingsJapgolly.vegaLite.vegaLiteStrings.description
    - typingsJapgolly.vegaLite.vegaLiteStrings.order
  */
  trait Channel
    extends StObject
       with ExtendedChannel
  
  /* Rewritten from type alias, can be one of: 
    - typingsJapgolly.vegaLite.vegaLiteStrings.color
    - typingsJapgolly.vegaLite.vegaLiteStrings.fill
    - typingsJapgolly.vegaLite.vegaLiteStrings.stroke
  */
  trait ColorChannel extends StObject
  object ColorChannel {
    
    inline def color: typingsJapgolly.vegaLite.vegaLiteStrings.color = "color".asInstanceOf[typingsJapgolly.vegaLite.vegaLiteStrings.color]
    
    inline def fill: typingsJapgolly.vegaLite.vegaLiteStrings.fill = "fill".asInstanceOf[typingsJapgolly.vegaLite.vegaLiteStrings.fill]
    
    inline def stroke: typingsJapgolly.vegaLite.vegaLiteStrings.stroke = "stroke".asInstanceOf[typingsJapgolly.vegaLite.vegaLiteStrings.stroke]
  }
  
  /* Rewritten from type alias, can be one of: 
    - typingsJapgolly.vegaLite.buildSrcChannelMod.Channel
    - typingsJapgolly.vegaLite.buildSrcChannelMod.FacetChannel
  */
  trait ExtendedChannel extends StObject
  
  /* keyof vega-lite.vega-lite/build/src/spec/facet.EncodingFacetMapping<any, any> */ /* Rewritten from type alias, can be one of: 
    - typingsJapgolly.vegaLite.vegaLiteStrings.facet
    - typingsJapgolly.vegaLite.vegaLiteStrings.row
    - typingsJapgolly.vegaLite.vegaLiteStrings.column
  */
  trait FacetChannel
    extends StObject
       with ExtendedChannel
  
  /* keyof vega-lite.anon.Latitude */ /* Rewritten from type alias, can be one of: 
    - typingsJapgolly.vegaLite.vegaLiteStrings.longitude
    - typingsJapgolly.vegaLite.vegaLiteStrings.longitude2
    - typingsJapgolly.vegaLite.vegaLiteStrings.latitude
    - typingsJapgolly.vegaLite.vegaLiteStrings.latitude2
  */
  trait GeoPositionChannel extends StObject
  
  /** NOTE: Conditional type definitions are impossible to translate to Scala.
    * See https://www.typescriptlang.org/docs/handbook/2/conditional-types.html for an intro.
    * You'll have to cast your way around this structure, unfortunately. 
    * TS definition: {{{
    C extends 'x2' ? 'x' : C extends 'y2' ? 'y' : C extends 'latitude2' ? 'latitude' : C extends 'longitude2' ? 'longitude' : C extends 'theta2' ? 'theta' : C extends 'radius2' ? 'radius' : C
    }}}
    */
  @js.native
  trait MainChannelOf[C /* <: ExtendedChannel */] extends StObject
  
  type NonPositionChannel = /* import warning: importer.ImportType#apply Failed type conversion: std.Array<'fill' | 'detail' | 'key' | 'url' | 'color' | 'fillOpacity' | 'opacity' | 'order' | 'stroke' | 'strokeOpacity' | 'strokeWidth' | 'text' | 'size' | 'description' | 'strokeDash' | 'tooltip' | 'angle' | 'shape' | 'href'>[number] */ js.Any
  
  type NonPositionScaleChannel = /* import warning: importer.ImportType#apply Failed type conversion: std.Array<'fill' | 'color' | 'fillOpacity' | 'opacity' | 'stroke' | 'strokeOpacity' | 'strokeWidth' | 'size' | 'strokeDash' | 'angle' | 'shape'>[number] */ js.Any
  
  type OffsetScaleChannel = /* import warning: importer.ImportType#apply Failed type conversion: std.Array<'xOffset' | 'yOffset'>[0] */ js.Any
  
  /* keyof vega-lite.anon.Radius */ /* Rewritten from type alias, can be one of: 
    - typingsJapgolly.vegaLite.vegaLiteStrings.theta
    - typingsJapgolly.vegaLite.vegaLiteStrings.theta2
    - typingsJapgolly.vegaLite.vegaLiteStrings.radius
    - typingsJapgolly.vegaLite.vegaLiteStrings.radius2
  */
  trait PolarPositionChannel extends StObject
  
  /* keyof vega-lite.anon.Theta */ /* Rewritten from type alias, can be one of: 
    - typingsJapgolly.vegaLite.vegaLiteStrings.theta
    - typingsJapgolly.vegaLite.vegaLiteStrings.radius
  */
  trait PolarPositionScaleChannel extends StObject
  
  /* keyof vega-lite.anon.X */ /* Rewritten from type alias, can be one of: 
    - typingsJapgolly.vegaLite.vegaLiteStrings.x
    - typingsJapgolly.vegaLite.vegaLiteStrings.y
    - typingsJapgolly.vegaLite.vegaLiteStrings.x2
    - typingsJapgolly.vegaLite.vegaLiteStrings.y2
  */
  trait PositionChannel extends StObject
  
  /* keyof vega-lite.anon.Y */ /* Rewritten from type alias, can be one of: 
    - typingsJapgolly.vegaLite.vegaLiteStrings.x
    - typingsJapgolly.vegaLite.vegaLiteStrings.y
  */
  trait PositionScaleChannel extends StObject
  
  type ScaleChannel = /* import warning: importer.ImportType#apply Failed type conversion: std.Array<'fill' | 'color' | 'fillOpacity' | 'opacity' | 'stroke' | 'strokeOpacity' | 'strokeWidth' | 'size' | 'x' | 'y' | 'strokeDash' | 'angle' | 'shape' | 'radius' | 'theta' | 'xOffset' | 'yOffset'>[number] */ js.Any
  
  /** NOTE: Conditional type definitions are impossible to translate to Scala.
    * See https://www.typescriptlang.org/docs/handbook/2/conditional-types.html for an intro.
    * You'll have to cast your way around this structure, unfortunately. 
    * TS definition: {{{
    C extends 'x' ? 'x2' : C extends 'y' ? 'y2' : C extends 'latitude' ? 'latitude2' : C extends 'longitude' ? 'longitude2' : C extends 'theta' ? 'theta2' : C extends 'radius' ? 'radius2' : undefined
    }}}
    */
  @js.native
  trait SecondaryChannelOf[C /* <: Channel */] extends StObject
  
  /* Rewritten from type alias, can be one of: 
    - typingsJapgolly.vegaLite.vegaLiteStrings.x2
    - typingsJapgolly.vegaLite.vegaLiteStrings.y2
    - typingsJapgolly.vegaLite.vegaLiteStrings.latitude2
    - typingsJapgolly.vegaLite.vegaLiteStrings.longitude2
    - typingsJapgolly.vegaLite.vegaLiteStrings.theta2
    - typingsJapgolly.vegaLite.vegaLiteStrings.radius2
  */
  trait SecondaryRangeChannel extends StObject
  object SecondaryRangeChannel {
    
    inline def latitude2: typingsJapgolly.vegaLite.vegaLiteStrings.latitude2 = "latitude2".asInstanceOf[typingsJapgolly.vegaLite.vegaLiteStrings.latitude2]
    
    inline def longitude2: typingsJapgolly.vegaLite.vegaLiteStrings.longitude2 = "longitude2".asInstanceOf[typingsJapgolly.vegaLite.vegaLiteStrings.longitude2]
    
    inline def radius2: typingsJapgolly.vegaLite.vegaLiteStrings.radius2 = "radius2".asInstanceOf[typingsJapgolly.vegaLite.vegaLiteStrings.radius2]
    
    inline def theta2: typingsJapgolly.vegaLite.vegaLiteStrings.theta2 = "theta2".asInstanceOf[typingsJapgolly.vegaLite.vegaLiteStrings.theta2]
    
    inline def x2: typingsJapgolly.vegaLite.vegaLiteStrings.x2 = "x2".asInstanceOf[typingsJapgolly.vegaLite.vegaLiteStrings.x2]
    
    inline def y2: typingsJapgolly.vegaLite.vegaLiteStrings.y2 = "y2".asInstanceOf[typingsJapgolly.vegaLite.vegaLiteStrings.y2]
  }
  
  type SingleDefChannel = /* import warning: importer.ImportType#apply Failed type conversion: std.Array<'fill' | 'key' | 'url' | 'color' | 'fillOpacity' | 'opacity' | 'stroke' | 'strokeOpacity' | 'strokeWidth' | 'text' | 'size' | 'description' | 'x' | 'x2' | 'y' | 'y2' | 'strokeDash' | 'angle' | 'shape' | 'radius' | 'theta' | 'facet' | 'href' | 'theta2' | 'radius2' | 'xOffset' | 'yOffset' | 'longitude' | 'latitude' | 'longitude2' | 'latitude2' | 'row' | 'column'>[number] */ js.Any
  
  type SingleDefUnitChannel = /* import warning: importer.ImportType#apply Failed type conversion: std.Array<'fill' | 'key' | 'url' | 'color' | 'fillOpacity' | 'opacity' | 'stroke' | 'strokeOpacity' | 'strokeWidth' | 'text' | 'size' | 'description' | 'x' | 'x2' | 'y' | 'y2' | 'strokeDash' | 'angle' | 'shape' | 'radius' | 'theta' | 'href' | 'theta2' | 'radius2' | 'xOffset' | 'yOffset' | 'longitude' | 'latitude' | 'longitude2' | 'latitude2'>[number] */ js.Any
  
  /* Inlined std.Partial<std.Record<vega-lite.vega-lite/build/src/mark.Mark, 'always' | 'binned'>> */
  trait SupportedMark extends StObject {
    
    var arc: js.UndefOr[always | binned] = js.undefined
    
    var area: js.UndefOr[always | binned] = js.undefined
    
    var bar: js.UndefOr[always | binned] = js.undefined
    
    var circle: js.UndefOr[always | binned] = js.undefined
    
    var geoshape: js.UndefOr[always | binned] = js.undefined
    
    var image: js.UndefOr[always | binned] = js.undefined
    
    var line: js.UndefOr[always | binned] = js.undefined
    
    var point: js.UndefOr[always | binned] = js.undefined
    
    var rect: js.UndefOr[always | binned] = js.undefined
    
    var rule: js.UndefOr[always | binned] = js.undefined
    
    var square: js.UndefOr[always | binned] = js.undefined
    
    var text: js.UndefOr[always | binned] = js.undefined
    
    var tick: js.UndefOr[always | binned] = js.undefined
    
    var trail: js.UndefOr[always | binned] = js.undefined
  }
  object SupportedMark {
    
    inline def apply(): SupportedMark = {
      val __obj = js.Dynamic.literal()
      __obj.asInstanceOf[SupportedMark]
    }
    
    extension [Self <: SupportedMark](x: Self) {
      
      inline def setArc(value: always | binned): Self = StObject.set(x, "arc", value.asInstanceOf[js.Any])
      
      inline def setArcUndefined: Self = StObject.set(x, "arc", js.undefined)
      
      inline def setArea(value: always | binned): Self = StObject.set(x, "area", value.asInstanceOf[js.Any])
      
      inline def setAreaUndefined: Self = StObject.set(x, "area", js.undefined)
      
      inline def setBar(value: always | binned): Self = StObject.set(x, "bar", value.asInstanceOf[js.Any])
      
      inline def setBarUndefined: Self = StObject.set(x, "bar", js.undefined)
      
      inline def setCircle(value: always | binned): Self = StObject.set(x, "circle", value.asInstanceOf[js.Any])
      
      inline def setCircleUndefined: Self = StObject.set(x, "circle", js.undefined)
      
      inline def setGeoshape(value: always | binned): Self = StObject.set(x, "geoshape", value.asInstanceOf[js.Any])
      
      inline def setGeoshapeUndefined: Self = StObject.set(x, "geoshape", js.undefined)
      
      inline def setImage(value: always | binned): Self = StObject.set(x, "image", value.asInstanceOf[js.Any])
      
      inline def setImageUndefined: Self = StObject.set(x, "image", js.undefined)
      
      inline def setLine(value: always | binned): Self = StObject.set(x, "line", value.asInstanceOf[js.Any])
      
      inline def setLineUndefined: Self = StObject.set(x, "line", js.undefined)
      
      inline def setPoint(value: always | binned): Self = StObject.set(x, "point", value.asInstanceOf[js.Any])
      
      inline def setPointUndefined: Self = StObject.set(x, "point", js.undefined)
      
      inline def setRect(value: always | binned): Self = StObject.set(x, "rect", value.asInstanceOf[js.Any])
      
      inline def setRectUndefined: Self = StObject.set(x, "rect", js.undefined)
      
      inline def setRule(value: always | binned): Self = StObject.set(x, "rule", value.asInstanceOf[js.Any])
      
      inline def setRuleUndefined: Self = StObject.set(x, "rule", js.undefined)
      
      inline def setSquare(value: always | binned): Self = StObject.set(x, "square", value.asInstanceOf[js.Any])
      
      inline def setSquareUndefined: Self = StObject.set(x, "square", js.undefined)
      
      inline def setText(value: always | binned): Self = StObject.set(x, "text", value.asInstanceOf[js.Any])
      
      inline def setTextUndefined: Self = StObject.set(x, "text", js.undefined)
      
      inline def setTick(value: always | binned): Self = StObject.set(x, "tick", value.asInstanceOf[js.Any])
      
      inline def setTickUndefined: Self = StObject.set(x, "tick", js.undefined)
      
      inline def setTrail(value: always | binned): Self = StObject.set(x, "trail", value.asInstanceOf[js.Any])
      
      inline def setTrailUndefined: Self = StObject.set(x, "trail", js.undefined)
    }
  }
}
