package typingsJapgolly.gremlin.mod.process

import japgolly.scalajs.react.CallbackTo
import scala.scalajs.js
import scala.scalajs.js.`|`
import scala.scalajs.js.annotation._

trait Statics_[T /* <: GraphTraversal */] extends js.Object {
  def V(args: js.Any*): T
  def addE(args: js.Any*): T
  def addV(args: js.Any*): T
  def aggregate(args: js.Any*): T
  def and(args: js.Any*): T
  def as(args: js.Any*): T
  def barrier(args: js.Any*): T
  def both(args: js.Any*): T
  def bothE(args: js.Any*): T
  def bothV(args: js.Any*): T
  def branch(args: js.Any*): T
  def cap(args: js.Any*): T
  def choose(args: js.Any*): T
  def coalesce(args: js.Any*): T
  def coin(args: js.Any*): T
  def constant(args: js.Any*): T
  def count(args: js.Any*): T
  def cyclicPath(args: js.Any*): T
  def dedup(args: js.Any*): T
  def drop(args: js.Any*): T
  def elementMap(args: js.Any*): T
  def emit(args: js.Any*): T
  def filter(args: js.Any*): T
  def flatMap(args: js.Any*): T
  def fold(args: js.Any*): T
  def group(args: js.Any*): T
  def groupCount(args: js.Any*): T
  def has(args: js.Any*): T
  def hasId(args: js.Any*): T
  def hasKey(args: js.Any*): T
  def hasLabel(args: js.Any*): T
  def hasNot(args: js.Any*): T
  def hasValue(args: js.Any*): T
  def id(args: js.Any*): T
  def identity(args: js.Any*): T
  def inE(args: js.Any*): T
  def inV(args: js.Any*): T
  def in_(args: js.Any*): T
  def index(args: js.Any*): T
  def inject(args: js.Any*): T
  def is(args: js.Any*): T
  def key(args: js.Any*): T
  def label(args: js.Any*): T
  def limit(args: js.Any*): T
  def local(args: js.Any*): T
  def loops(args: js.Any*): T
  def map(args: js.Any*): T
  def `match`(args: js.Any*): T
  def math(args: js.Any*): T
  def max(args: js.Any*): T
  def mean(args: js.Any*): T
  def min(args: js.Any*): T
  def not(args: js.Any*): T
  def optional(args: js.Any*): T
  def or(args: js.Any*): T
  def order(args: js.Any*): T
  def otherV(args: js.Any*): T
  def out(args: js.Any*): T
  def outE(args: js.Any*): T
  def outV(args: js.Any*): T
  def path(args: js.Any*): T
  def project(args: js.Any*): T
  def properties(args: js.Any*): T
  def property(args: js.Any*): T
  def propertyMap(args: js.Any*): T
  def range(args: js.Any*): T
  def repeat(args: js.Any*): T
  def sack(args: js.Any*): T
  def sample(args: js.Any*): T
  def select(args: js.Any*): T
  def sideEffect(args: js.Any*): T
  def simplePath(args: js.Any*): T
  def skip(args: js.Any*): T
  def store(args: js.Any*): T
  def subgraph(args: js.Any*): T
  def sum(args: js.Any*): T
  def tail(args: js.Any*): T
  def timeLimit(args: js.Any*): T
  def times(args: js.Any*): T
  def to(args: js.Any*): T
  def toE(args: js.Any*): T
  def toV(args: js.Any*): T
  def tree(args: js.Any*): T
  def unfold(args: js.Any*): T
  def union(args: js.Any*): T
  def until(args: js.Any*): T
  def value(args: js.Any*): T
  def valueMap(args: js.Any*): T
  def values(args: js.Any*): T
  def where(args: js.Any*): T
}

object Statics_ {
  @scala.inline
  def apply[T /* <: GraphTraversal */](
    V: /* repeated */ js.Any => CallbackTo[T],
    addE: /* repeated */ js.Any => CallbackTo[T],
    addV: /* repeated */ js.Any => CallbackTo[T],
    aggregate: /* repeated */ js.Any => CallbackTo[T],
    and: /* repeated */ js.Any => CallbackTo[T],
    as: /* repeated */ js.Any => CallbackTo[T],
    barrier: /* repeated */ js.Any => CallbackTo[T],
    both: /* repeated */ js.Any => CallbackTo[T],
    bothE: /* repeated */ js.Any => CallbackTo[T],
    bothV: /* repeated */ js.Any => CallbackTo[T],
    branch: /* repeated */ js.Any => CallbackTo[T],
    cap: /* repeated */ js.Any => CallbackTo[T],
    choose: /* repeated */ js.Any => CallbackTo[T],
    coalesce: /* repeated */ js.Any => CallbackTo[T],
    coin: /* repeated */ js.Any => CallbackTo[T],
    constant: /* repeated */ js.Any => CallbackTo[T],
    count: /* repeated */ js.Any => CallbackTo[T],
    cyclicPath: /* repeated */ js.Any => CallbackTo[T],
    dedup: /* repeated */ js.Any => CallbackTo[T],
    drop: /* repeated */ js.Any => CallbackTo[T],
    elementMap: /* repeated */ js.Any => CallbackTo[T],
    emit: /* repeated */ js.Any => CallbackTo[T],
    filter: /* repeated */ js.Any => CallbackTo[T],
    flatMap: /* repeated */ js.Any => CallbackTo[T],
    fold: /* repeated */ js.Any => CallbackTo[T],
    group: /* repeated */ js.Any => CallbackTo[T],
    groupCount: /* repeated */ js.Any => CallbackTo[T],
    has: /* repeated */ js.Any => CallbackTo[T],
    hasId: /* repeated */ js.Any => CallbackTo[T],
    hasKey: /* repeated */ js.Any => CallbackTo[T],
    hasLabel: /* repeated */ js.Any => CallbackTo[T],
    hasNot: /* repeated */ js.Any => CallbackTo[T],
    hasValue: /* repeated */ js.Any => CallbackTo[T],
    id: /* repeated */ js.Any => CallbackTo[T],
    identity: /* repeated */ js.Any => CallbackTo[T],
    inE: /* repeated */ js.Any => CallbackTo[T],
    inV: /* repeated */ js.Any => CallbackTo[T],
    in_ : /* repeated */ js.Any => CallbackTo[T],
    index: /* repeated */ js.Any => CallbackTo[T],
    inject: /* repeated */ js.Any => CallbackTo[T],
    is: /* repeated */ js.Any => CallbackTo[T],
    key: /* repeated */ js.Any => CallbackTo[T],
    label: /* repeated */ js.Any => CallbackTo[T],
    limit: /* repeated */ js.Any => CallbackTo[T],
    local: /* repeated */ js.Any => CallbackTo[T],
    loops: /* repeated */ js.Any => CallbackTo[T],
    map: /* repeated */ js.Any => CallbackTo[T],
    `match`: /* repeated */ js.Any => CallbackTo[T],
    math: /* repeated */ js.Any => CallbackTo[T],
    max: /* repeated */ js.Any => CallbackTo[T],
    mean: /* repeated */ js.Any => CallbackTo[T],
    min: /* repeated */ js.Any => CallbackTo[T],
    not: /* repeated */ js.Any => CallbackTo[T],
    optional: /* repeated */ js.Any => CallbackTo[T],
    or: /* repeated */ js.Any => CallbackTo[T],
    order: /* repeated */ js.Any => CallbackTo[T],
    otherV: /* repeated */ js.Any => CallbackTo[T],
    out: /* repeated */ js.Any => CallbackTo[T],
    outE: /* repeated */ js.Any => CallbackTo[T],
    outV: /* repeated */ js.Any => CallbackTo[T],
    path: /* repeated */ js.Any => CallbackTo[T],
    project: /* repeated */ js.Any => CallbackTo[T],
    properties: /* repeated */ js.Any => CallbackTo[T],
    property: /* repeated */ js.Any => CallbackTo[T],
    propertyMap: /* repeated */ js.Any => CallbackTo[T],
    range: /* repeated */ js.Any => CallbackTo[T],
    repeat: /* repeated */ js.Any => CallbackTo[T],
    sack: /* repeated */ js.Any => CallbackTo[T],
    sample: /* repeated */ js.Any => CallbackTo[T],
    select: /* repeated */ js.Any => CallbackTo[T],
    sideEffect: /* repeated */ js.Any => CallbackTo[T],
    simplePath: /* repeated */ js.Any => CallbackTo[T],
    skip: /* repeated */ js.Any => CallbackTo[T],
    store: /* repeated */ js.Any => CallbackTo[T],
    subgraph: /* repeated */ js.Any => CallbackTo[T],
    sum: /* repeated */ js.Any => CallbackTo[T],
    tail: /* repeated */ js.Any => CallbackTo[T],
    timeLimit: /* repeated */ js.Any => CallbackTo[T],
    times: /* repeated */ js.Any => CallbackTo[T],
    to: /* repeated */ js.Any => CallbackTo[T],
    toE: /* repeated */ js.Any => CallbackTo[T],
    toV: /* repeated */ js.Any => CallbackTo[T],
    tree: /* repeated */ js.Any => CallbackTo[T],
    unfold: /* repeated */ js.Any => CallbackTo[T],
    union: /* repeated */ js.Any => CallbackTo[T],
    until: /* repeated */ js.Any => CallbackTo[T],
    value: /* repeated */ js.Any => CallbackTo[T],
    valueMap: /* repeated */ js.Any => CallbackTo[T],
    values: /* repeated */ js.Any => CallbackTo[T],
    where: /* repeated */ js.Any => CallbackTo[T]
  ): Statics_[T] = {
    val __obj = js.Dynamic.literal()
    __obj.updateDynamic("V")(js.Any.fromFunction1((t0: /* repeated */ js.Any) => V(t0).runNow()))
    __obj.updateDynamic("addE")(js.Any.fromFunction1((t0: /* repeated */ js.Any) => addE(t0).runNow()))
    __obj.updateDynamic("addV")(js.Any.fromFunction1((t0: /* repeated */ js.Any) => addV(t0).runNow()))
    __obj.updateDynamic("aggregate")(js.Any.fromFunction1((t0: /* repeated */ js.Any) => aggregate(t0).runNow()))
    __obj.updateDynamic("and")(js.Any.fromFunction1((t0: /* repeated */ js.Any) => and(t0).runNow()))
    __obj.updateDynamic("as")(js.Any.fromFunction1((t0: /* repeated */ js.Any) => as(t0).runNow()))
    __obj.updateDynamic("barrier")(js.Any.fromFunction1((t0: /* repeated */ js.Any) => barrier(t0).runNow()))
    __obj.updateDynamic("both")(js.Any.fromFunction1((t0: /* repeated */ js.Any) => both(t0).runNow()))
    __obj.updateDynamic("bothE")(js.Any.fromFunction1((t0: /* repeated */ js.Any) => bothE(t0).runNow()))
    __obj.updateDynamic("bothV")(js.Any.fromFunction1((t0: /* repeated */ js.Any) => bothV(t0).runNow()))
    __obj.updateDynamic("branch")(js.Any.fromFunction1((t0: /* repeated */ js.Any) => branch(t0).runNow()))
    __obj.updateDynamic("cap")(js.Any.fromFunction1((t0: /* repeated */ js.Any) => cap(t0).runNow()))
    __obj.updateDynamic("choose")(js.Any.fromFunction1((t0: /* repeated */ js.Any) => choose(t0).runNow()))
    __obj.updateDynamic("coalesce")(js.Any.fromFunction1((t0: /* repeated */ js.Any) => coalesce(t0).runNow()))
    __obj.updateDynamic("coin")(js.Any.fromFunction1((t0: /* repeated */ js.Any) => coin(t0).runNow()))
    __obj.updateDynamic("constant")(js.Any.fromFunction1((t0: /* repeated */ js.Any) => constant(t0).runNow()))
    __obj.updateDynamic("count")(js.Any.fromFunction1((t0: /* repeated */ js.Any) => count(t0).runNow()))
    __obj.updateDynamic("cyclicPath")(js.Any.fromFunction1((t0: /* repeated */ js.Any) => cyclicPath(t0).runNow()))
    __obj.updateDynamic("dedup")(js.Any.fromFunction1((t0: /* repeated */ js.Any) => dedup(t0).runNow()))
    __obj.updateDynamic("drop")(js.Any.fromFunction1((t0: /* repeated */ js.Any) => drop(t0).runNow()))
    __obj.updateDynamic("elementMap")(js.Any.fromFunction1((t0: /* repeated */ js.Any) => elementMap(t0).runNow()))
    __obj.updateDynamic("emit")(js.Any.fromFunction1((t0: /* repeated */ js.Any) => emit(t0).runNow()))
    __obj.updateDynamic("filter")(js.Any.fromFunction1((t0: /* repeated */ js.Any) => filter(t0).runNow()))
    __obj.updateDynamic("flatMap")(js.Any.fromFunction1((t0: /* repeated */ js.Any) => flatMap(t0).runNow()))
    __obj.updateDynamic("fold")(js.Any.fromFunction1((t0: /* repeated */ js.Any) => fold(t0).runNow()))
    __obj.updateDynamic("group")(js.Any.fromFunction1((t0: /* repeated */ js.Any) => group(t0).runNow()))
    __obj.updateDynamic("groupCount")(js.Any.fromFunction1((t0: /* repeated */ js.Any) => groupCount(t0).runNow()))
    __obj.updateDynamic("has")(js.Any.fromFunction1((t0: /* repeated */ js.Any) => has(t0).runNow()))
    __obj.updateDynamic("hasId")(js.Any.fromFunction1((t0: /* repeated */ js.Any) => hasId(t0).runNow()))
    __obj.updateDynamic("hasKey")(js.Any.fromFunction1((t0: /* repeated */ js.Any) => hasKey(t0).runNow()))
    __obj.updateDynamic("hasLabel")(js.Any.fromFunction1((t0: /* repeated */ js.Any) => hasLabel(t0).runNow()))
    __obj.updateDynamic("hasNot")(js.Any.fromFunction1((t0: /* repeated */ js.Any) => hasNot(t0).runNow()))
    __obj.updateDynamic("hasValue")(js.Any.fromFunction1((t0: /* repeated */ js.Any) => hasValue(t0).runNow()))
    __obj.updateDynamic("id")(js.Any.fromFunction1((t0: /* repeated */ js.Any) => id(t0).runNow()))
    __obj.updateDynamic("identity")(js.Any.fromFunction1((t0: /* repeated */ js.Any) => identity(t0).runNow()))
    __obj.updateDynamic("inE")(js.Any.fromFunction1((t0: /* repeated */ js.Any) => inE(t0).runNow()))
    __obj.updateDynamic("inV")(js.Any.fromFunction1((t0: /* repeated */ js.Any) => inV(t0).runNow()))
    __obj.updateDynamic("in_")(js.Any.fromFunction1((t0: /* repeated */ js.Any) => in_(t0).runNow()))
    __obj.updateDynamic("index")(js.Any.fromFunction1((t0: /* repeated */ js.Any) => index(t0).runNow()))
    __obj.updateDynamic("inject")(js.Any.fromFunction1((t0: /* repeated */ js.Any) => inject(t0).runNow()))
    __obj.updateDynamic("is")(js.Any.fromFunction1((t0: /* repeated */ js.Any) => is(t0).runNow()))
    __obj.updateDynamic("key")(js.Any.fromFunction1((t0: /* repeated */ js.Any) => key(t0).runNow()))
    __obj.updateDynamic("label")(js.Any.fromFunction1((t0: /* repeated */ js.Any) => label(t0).runNow()))
    __obj.updateDynamic("limit")(js.Any.fromFunction1((t0: /* repeated */ js.Any) => limit(t0).runNow()))
    __obj.updateDynamic("local")(js.Any.fromFunction1((t0: /* repeated */ js.Any) => local(t0).runNow()))
    __obj.updateDynamic("loops")(js.Any.fromFunction1((t0: /* repeated */ js.Any) => loops(t0).runNow()))
    __obj.updateDynamic("map")(js.Any.fromFunction1((t0: /* repeated */ js.Any) => map(t0).runNow()))
    __obj.updateDynamic("match")(js.Any.fromFunction1((t0: /* repeated */ js.Any) => `match`(t0).runNow()))
    __obj.updateDynamic("math")(js.Any.fromFunction1((t0: /* repeated */ js.Any) => math(t0).runNow()))
    __obj.updateDynamic("max")(js.Any.fromFunction1((t0: /* repeated */ js.Any) => max(t0).runNow()))
    __obj.updateDynamic("mean")(js.Any.fromFunction1((t0: /* repeated */ js.Any) => mean(t0).runNow()))
    __obj.updateDynamic("min")(js.Any.fromFunction1((t0: /* repeated */ js.Any) => min(t0).runNow()))
    __obj.updateDynamic("not")(js.Any.fromFunction1((t0: /* repeated */ js.Any) => not(t0).runNow()))
    __obj.updateDynamic("optional")(js.Any.fromFunction1((t0: /* repeated */ js.Any) => optional(t0).runNow()))
    __obj.updateDynamic("or")(js.Any.fromFunction1((t0: /* repeated */ js.Any) => or(t0).runNow()))
    __obj.updateDynamic("order")(js.Any.fromFunction1((t0: /* repeated */ js.Any) => order(t0).runNow()))
    __obj.updateDynamic("otherV")(js.Any.fromFunction1((t0: /* repeated */ js.Any) => otherV(t0).runNow()))
    __obj.updateDynamic("out")(js.Any.fromFunction1((t0: /* repeated */ js.Any) => out(t0).runNow()))
    __obj.updateDynamic("outE")(js.Any.fromFunction1((t0: /* repeated */ js.Any) => outE(t0).runNow()))
    __obj.updateDynamic("outV")(js.Any.fromFunction1((t0: /* repeated */ js.Any) => outV(t0).runNow()))
    __obj.updateDynamic("path")(js.Any.fromFunction1((t0: /* repeated */ js.Any) => path(t0).runNow()))
    __obj.updateDynamic("project")(js.Any.fromFunction1((t0: /* repeated */ js.Any) => project(t0).runNow()))
    __obj.updateDynamic("properties")(js.Any.fromFunction1((t0: /* repeated */ js.Any) => properties(t0).runNow()))
    __obj.updateDynamic("property")(js.Any.fromFunction1((t0: /* repeated */ js.Any) => property(t0).runNow()))
    __obj.updateDynamic("propertyMap")(js.Any.fromFunction1((t0: /* repeated */ js.Any) => propertyMap(t0).runNow()))
    __obj.updateDynamic("range")(js.Any.fromFunction1((t0: /* repeated */ js.Any) => range(t0).runNow()))
    __obj.updateDynamic("repeat")(js.Any.fromFunction1((t0: /* repeated */ js.Any) => repeat(t0).runNow()))
    __obj.updateDynamic("sack")(js.Any.fromFunction1((t0: /* repeated */ js.Any) => sack(t0).runNow()))
    __obj.updateDynamic("sample")(js.Any.fromFunction1((t0: /* repeated */ js.Any) => sample(t0).runNow()))
    __obj.updateDynamic("select")(js.Any.fromFunction1((t0: /* repeated */ js.Any) => select(t0).runNow()))
    __obj.updateDynamic("sideEffect")(js.Any.fromFunction1((t0: /* repeated */ js.Any) => sideEffect(t0).runNow()))
    __obj.updateDynamic("simplePath")(js.Any.fromFunction1((t0: /* repeated */ js.Any) => simplePath(t0).runNow()))
    __obj.updateDynamic("skip")(js.Any.fromFunction1((t0: /* repeated */ js.Any) => skip(t0).runNow()))
    __obj.updateDynamic("store")(js.Any.fromFunction1((t0: /* repeated */ js.Any) => store(t0).runNow()))
    __obj.updateDynamic("subgraph")(js.Any.fromFunction1((t0: /* repeated */ js.Any) => subgraph(t0).runNow()))
    __obj.updateDynamic("sum")(js.Any.fromFunction1((t0: /* repeated */ js.Any) => sum(t0).runNow()))
    __obj.updateDynamic("tail")(js.Any.fromFunction1((t0: /* repeated */ js.Any) => tail(t0).runNow()))
    __obj.updateDynamic("timeLimit")(js.Any.fromFunction1((t0: /* repeated */ js.Any) => timeLimit(t0).runNow()))
    __obj.updateDynamic("times")(js.Any.fromFunction1((t0: /* repeated */ js.Any) => times(t0).runNow()))
    __obj.updateDynamic("to")(js.Any.fromFunction1((t0: /* repeated */ js.Any) => to(t0).runNow()))
    __obj.updateDynamic("toE")(js.Any.fromFunction1((t0: /* repeated */ js.Any) => toE(t0).runNow()))
    __obj.updateDynamic("toV")(js.Any.fromFunction1((t0: /* repeated */ js.Any) => toV(t0).runNow()))
    __obj.updateDynamic("tree")(js.Any.fromFunction1((t0: /* repeated */ js.Any) => tree(t0).runNow()))
    __obj.updateDynamic("unfold")(js.Any.fromFunction1((t0: /* repeated */ js.Any) => unfold(t0).runNow()))
    __obj.updateDynamic("union")(js.Any.fromFunction1((t0: /* repeated */ js.Any) => union(t0).runNow()))
    __obj.updateDynamic("until")(js.Any.fromFunction1((t0: /* repeated */ js.Any) => until(t0).runNow()))
    __obj.updateDynamic("value")(js.Any.fromFunction1((t0: /* repeated */ js.Any) => value(t0).runNow()))
    __obj.updateDynamic("valueMap")(js.Any.fromFunction1((t0: /* repeated */ js.Any) => valueMap(t0).runNow()))
    __obj.updateDynamic("values")(js.Any.fromFunction1((t0: /* repeated */ js.Any) => values(t0).runNow()))
    __obj.updateDynamic("where")(js.Any.fromFunction1((t0: /* repeated */ js.Any) => where(t0).runNow()))
    __obj.asInstanceOf[Statics_[T]]
  }
}

