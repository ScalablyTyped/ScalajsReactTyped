package typingsJapgolly.googleapis.v1beta4Mod.sqladminV1beta4

import scala.scalajs.js
import scala.scalajs.js.`|`
import scala.scalajs.js.annotation._

/**
  * SslCert insert response.
  */
@js.native
trait SchemaSslCertsInsertResponse extends js.Object {
  /**
    * The new client certificate and private key. For First Generation
    * instances, the new certificate does not take effect until the instance is
    * restarted.
    */
  var clientCert: js.UndefOr[SchemaSslCertDetail] = js.native
  /**
    * This is always sql#sslCertsInsert.
    */
  var kind: js.UndefOr[String] = js.native
  /**
    * The operation to track the ssl certs insert request.
    */
  var operation: js.UndefOr[SchemaOperation] = js.native
  /**
    * The server Certificate Authority&#39;s certificate. If this is missing
    * you can force a new one to be generated by calling resetSslConfig method
    * on instances resource.
    */
  var serverCaCert: js.UndefOr[SchemaSslCert] = js.native
}

object SchemaSslCertsInsertResponse {
  @scala.inline
  def apply(
    clientCert: SchemaSslCertDetail = null,
    kind: String = null,
    operation: SchemaOperation = null,
    serverCaCert: SchemaSslCert = null
  ): SchemaSslCertsInsertResponse = {
    val __obj = js.Dynamic.literal()
    if (clientCert != null) __obj.updateDynamic("clientCert")(clientCert.asInstanceOf[js.Any])
    if (kind != null) __obj.updateDynamic("kind")(kind.asInstanceOf[js.Any])
    if (operation != null) __obj.updateDynamic("operation")(operation.asInstanceOf[js.Any])
    if (serverCaCert != null) __obj.updateDynamic("serverCaCert")(serverCaCert.asInstanceOf[js.Any])
    __obj.asInstanceOf[SchemaSslCertsInsertResponse]
  }
}

