package typingsJapgolly.reactMdForm

import japgolly.scalajs.react.Callback
import japgolly.scalajs.react.ReactDragEventFrom
import japgolly.scalajs.react.ReactEventFrom
import org.scalajs.dom.Element
import org.scalajs.dom.File
import org.scalajs.dom.HTMLElement
import org.scalajs.dom.HTMLInputElement
import typingsJapgolly.react.mod.ChangeEventHandler
import typingsJapgolly.react.mod.DragEventHandler
import typingsJapgolly.reactMdForm.reactMdFormStrings.complete
import typingsJapgolly.reactMdForm.reactMdFormStrings.max
import typingsJapgolly.reactMdForm.reactMdFormStrings.min
import typingsJapgolly.reactMdForm.reactMdFormStrings.pending
import typingsJapgolly.reactMdForm.reactMdFormStrings.total
import typingsJapgolly.reactMdForm.reactMdFormStrings.uploading
import typingsJapgolly.std.Error
import org.scalablytyped.runtime.StObject
import scala.scalajs.js
import scala.scalajs.js.annotation.{JSGlobalScope, JSGlobal, JSImport, JSName, JSBracketAccess}

object typesFileInputUtilsMod {
  
  @JSImport("@react-md/form/types/file-input/utils", JSImport.Namespace)
  @js.native
  val ^ : js.Any = js.native
  
  @JSImport("@react-md/form/types/file-input/utils", "FileAccessError")
  @js.native
  /**
    *
    * @param message - An optional message for the error.
    */
  open class FileAccessError ()
    extends StObject
       with Error
       with _FileValidationError[Any] {
    def this(message: String) = this()
    
    /**
      * A unique key generated by `nanoid` that can be used as a `React` key
      */
    var key: String = js.native
    
    /* standard es5 */
    /* CompleteClass */
    var message: String = js.native
    
    /* standard es5 */
    /* CompleteClass */
    var name: String = js.native
  }
  
  @JSImport("@react-md/form/types/file-input/utils", "FileExtensionError")
  @js.native
  open class FileExtensionError protected ()
    extends GenericFileError
       with _FileValidationError[Any] {
    /**
      *
      * @param files - The file that caused the error
      * @param extensions - The allowed list of file extensions
      */
    def this(files: js.Array[File], extensions: js.Array[String]) = this()
    
    var extensions: js.Array[String] = js.native
  }
  
  @JSImport("@react-md/form/types/file-input/utils", "FileSizeError")
  @js.native
  open class FileSizeError protected ()
    extends GenericFileError
       with _FileValidationError[Any] {
    /**
      *
      * @param files - The list of files that have the file size error
      * @param type - The file size error type
      * @param limit - The number of bytes allowed based on the type
      */
    def this(files: js.Array[File], `type`: min | max | total, limit: Double) = this()
    
    var limit: Double = js.native
    
    var `type`: min | max | total = js.native
  }
  
  @JSImport("@react-md/form/types/file-input/utils", "GenericFileError")
  @js.native
  open class GenericFileError protected ()
    extends StObject
       with Error {
    /**
      *
      * @param files - A list of files that caused the error.
      * @param reason - An optional reason for the error
      */
    def this(files: js.Array[File]) = this()
    def this(files: js.Array[File], reason: String) = this()
    
    var files: js.Array[File] = js.native
    
    /**
      * A unique key generated by `nanoid` that can be used as a `React` key
      */
    var key: String = js.native
    
    /* standard es5 */
    /* CompleteClass */
    var message: String = js.native
    
    /* standard es5 */
    /* CompleteClass */
    var name: String = js.native
    
    var reason: js.UndefOr[String] = js.native
  }
  
  @JSImport("@react-md/form/types/file-input/utils", "TooManyFilesError")
  @js.native
  open class TooManyFilesError protected ()
    extends GenericFileError
       with _FileValidationError[Any] {
    /**
      *
      * @param files - The list of files that could not be uploaded due to the file
      * limit defined.
      * @param limit - The max limit of files allowed.
      */
    def this(files: js.Array[File], limit: Double) = this()
    
    var limit: Double = js.native
  }
  
  @JSImport("@react-md/form/types/file-input/utils", "getFileParser")
  @js.native
  val getFileParser: GetFileParser_ = js.native
  
  inline def getSplitFileUploads(stats: js.Array[FileUploadStats]): SplitFileUploads = ^.asInstanceOf[js.Dynamic].applyDynamic("getSplitFileUploads")(stats.asInstanceOf[js.Any]).asInstanceOf[SplitFileUploads]
  
  inline def isAudioFile(file: File): Boolean = ^.asInstanceOf[js.Dynamic].applyDynamic("isAudioFile")(file.asInstanceOf[js.Any]).asInstanceOf[Boolean]
  
  inline def isFileAccessError[CustomError](error: FileValidationError[CustomError]): /* is @react-md/form.@react-md/form/types/file-input/utils.FileAccessError */ Boolean = ^.asInstanceOf[js.Dynamic].applyDynamic("isFileAccessError")(error.asInstanceOf[js.Any]).asInstanceOf[/* is @react-md/form.@react-md/form/types/file-input/utils.FileAccessError */ Boolean]
  
  inline def isFileExtensionError[CustomError](error: FileValidationError[CustomError]): /* is @react-md/form.@react-md/form/types/file-input/utils.FileExtensionError */ Boolean = ^.asInstanceOf[js.Dynamic].applyDynamic("isFileExtensionError")(error.asInstanceOf[js.Any]).asInstanceOf[/* is @react-md/form.@react-md/form/types/file-input/utils.FileExtensionError */ Boolean]
  
  inline def isFileSizeError[CustomError](error: FileValidationError[CustomError]): /* is @react-md/form.@react-md/form/types/file-input/utils.FileSizeError */ Boolean = ^.asInstanceOf[js.Dynamic].applyDynamic("isFileSizeError")(error.asInstanceOf[js.Any]).asInstanceOf[/* is @react-md/form.@react-md/form/types/file-input/utils.FileSizeError */ Boolean]
  
  inline def isGenericFileError[CustomError](error: FileValidationError[CustomError]): /* is @react-md/form.@react-md/form/types/file-input/utils.GenericFileError */ Boolean = ^.asInstanceOf[js.Dynamic].applyDynamic("isGenericFileError")(error.asInstanceOf[js.Any]).asInstanceOf[/* is @react-md/form.@react-md/form/types/file-input/utils.GenericFileError */ Boolean]
  
  inline def isImageFile(file: File): Boolean = ^.asInstanceOf[js.Dynamic].applyDynamic("isImageFile")(file.asInstanceOf[js.Any]).asInstanceOf[Boolean]
  
  inline def isMediaFile(file: File): Boolean = ^.asInstanceOf[js.Dynamic].applyDynamic("isMediaFile")(file.asInstanceOf[js.Any]).asInstanceOf[Boolean]
  
  inline def isTextFile(file: File): Boolean = ^.asInstanceOf[js.Dynamic].applyDynamic("isTextFile")(file.asInstanceOf[js.Any]).asInstanceOf[Boolean]
  
  inline def isTooManyFilesError[CustomError](error: FileValidationError[CustomError]): /* is @react-md/form.@react-md/form/types/file-input/utils.TooManyFilesError */ Boolean = ^.asInstanceOf[js.Dynamic].applyDynamic("isTooManyFilesError")(error.asInstanceOf[js.Any]).asInstanceOf[/* is @react-md/form.@react-md/form/types/file-input/utils.TooManyFilesError */ Boolean]
  
  @JSImport("@react-md/form/types/file-input/utils", "isValidFileName")
  @js.native
  val isValidFileName: IsValidFileName_ = js.native
  
  inline def isVideoFile(file: File): Boolean = ^.asInstanceOf[js.Dynamic].applyDynamic("isVideoFile")(file.asInstanceOf[js.Any]).asInstanceOf[Boolean]
  
  inline def validateFiles[CustomError](
    files: js.Array[File],
    hasMaxFilesExtensionsMinFileSizeMaxFileSizeTotalBytesTotalFilesTotalFileSizeIsValidFileName: FilesValidationOptions
  ): ValidatedFilesResult[CustomError] = (^.asInstanceOf[js.Dynamic].applyDynamic("validateFiles")(files.asInstanceOf[js.Any], hasMaxFilesExtensionsMinFileSizeMaxFileSizeTotalBytesTotalFilesTotalFileSizeIsValidFileName.asInstanceOf[js.Any])).asInstanceOf[ValidatedFilesResult[CustomError]]
  
  trait BaseFileUploadStats extends StObject {
    
    /**
      * The file instance that is being uploaded.
      */
    var file: File
    
    /**
      * A unique key associated with each upload generated by `nanoid`.
      */
    var key: String
    
    /**
      * The current upload progress as a percentage from 0 - 100 percent.
      */
    var progress: Double
  }
  object BaseFileUploadStats {
    
    inline def apply(file: File, key: String, progress: Double): BaseFileUploadStats = {
      val __obj = js.Dynamic.literal(file = file.asInstanceOf[js.Any], key = key.asInstanceOf[js.Any], progress = progress.asInstanceOf[js.Any])
      __obj.asInstanceOf[BaseFileUploadStats]
    }
    
    extension [Self <: BaseFileUploadStats](x: Self) {
      
      inline def setFile(value: File): Self = StObject.set(x, "file", value.asInstanceOf[js.Any])
      
      inline def setKey(value: String): Self = StObject.set(x, "key", value.asInstanceOf[js.Any])
      
      inline def setProgress(value: Double): Self = StObject.set(x, "progress", value.asInstanceOf[js.Any])
    }
  }
  
  trait CompletedFileUploadStats
    extends StObject
       with BaseFileUploadStats
       with FileUploadStats {
    
    /**
      * The result after a `FileReader` has read a file completely.
      *
      * Note: This _should_ be an `ArrayBuffer` if the next step is to upload to a
      * server.
      *
      * @see {@link FileReaderParser}
      * @see {@link getFileParser}
      * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/FileReader | FileReader}
      */
    var result: FileReaderResult
    
    var status: complete
  }
  object CompletedFileUploadStats {
    
    inline def apply(file: File, key: String, progress: Double): CompletedFileUploadStats = {
      val __obj = js.Dynamic.literal(file = file.asInstanceOf[js.Any], key = key.asInstanceOf[js.Any], progress = progress.asInstanceOf[js.Any], status = "complete", result = null)
      __obj.asInstanceOf[CompletedFileUploadStats]
    }
    
    extension [Self <: CompletedFileUploadStats](x: Self) {
      
      inline def setResult(value: FileReaderResult): Self = StObject.set(x, "result", value.asInstanceOf[js.Any])
      
      inline def setResultNull: Self = StObject.set(x, "result", null)
      
      inline def setStatus(value: complete): Self = StObject.set(x, "status", value.asInstanceOf[js.Any])
    }
  }
  
  /* Rewritten from type alias, can be one of: 
    - typingsJapgolly.reactMdForm.reactMdFormStrings.readAsText
    - typingsJapgolly.reactMdForm.reactMdFormStrings.readAsDataURL
    - typingsJapgolly.reactMdForm.reactMdFormStrings.readAsBinaryString
    - typingsJapgolly.reactMdForm.reactMdFormStrings.readAsArrayBuffer
  */
  trait FileReaderParser extends StObject
  object FileReaderParser {
    
    inline def readAsArrayBuffer: typingsJapgolly.reactMdForm.reactMdFormStrings.readAsArrayBuffer = "readAsArrayBuffer".asInstanceOf[typingsJapgolly.reactMdForm.reactMdFormStrings.readAsArrayBuffer]
    
    inline def readAsBinaryString: typingsJapgolly.reactMdForm.reactMdFormStrings.readAsBinaryString = "readAsBinaryString".asInstanceOf[typingsJapgolly.reactMdForm.reactMdFormStrings.readAsBinaryString]
    
    inline def readAsDataURL: typingsJapgolly.reactMdForm.reactMdFormStrings.readAsDataURL = "readAsDataURL".asInstanceOf[typingsJapgolly.reactMdForm.reactMdFormStrings.readAsDataURL]
    
    inline def readAsText: typingsJapgolly.reactMdForm.reactMdFormStrings.readAsText = "readAsText".asInstanceOf[typingsJapgolly.reactMdForm.reactMdFormStrings.readAsText]
  }
  
  type FileReaderResult = String | js.typedarray.ArrayBuffer | Null
  
  trait FileUploadHandlers[E /* <: HTMLElement */] extends StObject {
    
    var onChange: js.UndefOr[ChangeEventHandler[HTMLInputElement]] = js.undefined
    
    var onDrop: js.UndefOr[DragEventHandler[E]] = js.undefined
  }
  object FileUploadHandlers {
    
    inline def apply[E /* <: HTMLElement */](): FileUploadHandlers[E] = {
      val __obj = js.Dynamic.literal()
      __obj.asInstanceOf[FileUploadHandlers[E]]
    }
    
    extension [Self <: FileUploadHandlers[?], E /* <: HTMLElement */](x: Self & FileUploadHandlers[E]) {
      
      inline def setOnChange(value: ReactEventFrom[HTMLInputElement & Element] => Callback): Self = StObject.set(x, "onChange", js.Any.fromFunction1((t0: ReactEventFrom[HTMLInputElement & Element]) => value(t0).runNow()))
      
      inline def setOnChangeUndefined: Self = StObject.set(x, "onChange", js.undefined)
      
      inline def setOnDrop(value: ReactDragEventFrom[E & Element] => Callback): Self = StObject.set(x, "onDrop", js.Any.fromFunction1((t0: ReactDragEventFrom[E & Element]) => value(t0).runNow()))
      
      inline def setOnDropUndefined: Self = StObject.set(x, "onDrop", js.undefined)
    }
  }
  
  /* Rewritten from type alias, can be one of: 
    - typingsJapgolly.reactMdForm.typesFileInputUtilsMod.ProcessingFileUploadStats
    - typingsJapgolly.reactMdForm.typesFileInputUtilsMod.CompletedFileUploadStats
  */
  trait FileUploadStats extends StObject
  object FileUploadStats {
    
    inline def CompletedFileUploadStats(file: File, key: String, progress: Double): typingsJapgolly.reactMdForm.typesFileInputUtilsMod.CompletedFileUploadStats = {
      val __obj = js.Dynamic.literal(file = file.asInstanceOf[js.Any], key = key.asInstanceOf[js.Any], progress = progress.asInstanceOf[js.Any], status = "complete", result = null)
      __obj.asInstanceOf[typingsJapgolly.reactMdForm.typesFileInputUtilsMod.CompletedFileUploadStats]
    }
    
    inline def ProcessingFileUploadStats(file: File, key: String, progress: Double, status: pending | uploading): typingsJapgolly.reactMdForm.typesFileInputUtilsMod.ProcessingFileUploadStats = {
      val __obj = js.Dynamic.literal(file = file.asInstanceOf[js.Any], key = key.asInstanceOf[js.Any], progress = progress.asInstanceOf[js.Any], status = status.asInstanceOf[js.Any])
      __obj.asInstanceOf[typingsJapgolly.reactMdForm.typesFileInputUtilsMod.ProcessingFileUploadStats]
    }
  }
  
  /* Inlined @react-md/form.@react-md/form/types/file-input/utils.FileUploadStats['status'] */
  /* Rewritten from type alias, can be one of: 
    - typingsJapgolly.reactMdForm.reactMdFormStrings.pending
    - typingsJapgolly.reactMdForm.reactMdFormStrings.uploading
    - typingsJapgolly.reactMdForm.reactMdFormStrings.complete
  */
  trait FileUploadStatus extends StObject
  object FileUploadStatus {
    
    inline def complete: typingsJapgolly.reactMdForm.reactMdFormStrings.complete = "complete".asInstanceOf[typingsJapgolly.reactMdForm.reactMdFormStrings.complete]
    
    inline def pending: typingsJapgolly.reactMdForm.reactMdFormStrings.pending = "pending".asInstanceOf[typingsJapgolly.reactMdForm.reactMdFormStrings.pending]
    
    inline def uploading: typingsJapgolly.reactMdForm.reactMdFormStrings.uploading = "uploading".asInstanceOf[typingsJapgolly.reactMdForm.reactMdFormStrings.uploading]
  }
  
  /* Rewritten from type alias, can be one of: 
    - typingsJapgolly.reactMdForm.typesFileInputUtilsMod.FileAccessError
    - typingsJapgolly.reactMdForm.typesFileInputUtilsMod.TooManyFilesError
    - typingsJapgolly.reactMdForm.typesFileInputUtilsMod.FileSizeError
    - typingsJapgolly.reactMdForm.typesFileInputUtilsMod.FileExtensionError
    - E
  */
  type FileValidationError[E] = _FileValidationError[E] | E
  
  trait FileValidationOptions extends StObject {
    
    /**
      * An optional list of extensions to enforce when uploading files.
      *
      * Note: The extensions and file names will be compared ignoring case.
      *
      * @example
      * Only Allow Images
      * ```ts
      * const extensions = ["png", "jpeg", "jpg", "gif"];
      * ```
      */
    var extensions: js.UndefOr[js.Array[String]] = js.undefined
    
    /** {@inheritDoc IsValidFileName} */
    var isValidFileName: js.UndefOr[IsValidFileName_] = js.undefined
    
    /**
      * An optional maximum file size to enforce for each file. This will only be
      * used when it is greater than `0`.
      *
      * @defaultValue `-1`
      */
    var maxFileSize: js.UndefOr[Double] = js.undefined
    
    /**
      * If the number of files should be limited, set this value to a number
      * greater than `0`.
      *
      * Note: This still allows "infinite" files when set to `0` since the
      * `<input>` element should normally be set to `disabled` if files should not
      * be able to be uploaded.
      *
      * @defaultValue `-1`
      */
    var maxFiles: js.UndefOr[Double] = js.undefined
    
    /**
      * An optional minimum file size to enforce for each file. This will only be
      * used when it is greater than `0`.
      *
      * @defaultValue `-1`
      */
    var minFileSize: js.UndefOr[Double] = js.undefined
    
    /**
      * An optional total file size to enforce when the {@link maxFiles} option is
      * not set to `1`.
      *
      * @defaultValue `-1`
      */
    var totalFileSize: js.UndefOr[Double] = js.undefined
  }
  object FileValidationOptions {
    
    inline def apply(): FileValidationOptions = {
      val __obj = js.Dynamic.literal()
      __obj.asInstanceOf[FileValidationOptions]
    }
    
    extension [Self <: FileValidationOptions](x: Self) {
      
      inline def setExtensions(value: js.Array[String]): Self = StObject.set(x, "extensions", value.asInstanceOf[js.Any])
      
      inline def setExtensionsUndefined: Self = StObject.set(x, "extensions", js.undefined)
      
      inline def setExtensionsVarargs(value: String*): Self = StObject.set(x, "extensions", js.Array(value*))
      
      inline def setIsValidFileName(
        value: (/* file */ File, /* extensionRegExp */ js.UndefOr[js.RegExp], /* extensions */ js.Array[String]) => Boolean
      ): Self = StObject.set(x, "isValidFileName", js.Any.fromFunction3(value))
      
      inline def setIsValidFileNameUndefined: Self = StObject.set(x, "isValidFileName", js.undefined)
      
      inline def setMaxFileSize(value: Double): Self = StObject.set(x, "maxFileSize", value.asInstanceOf[js.Any])
      
      inline def setMaxFileSizeUndefined: Self = StObject.set(x, "maxFileSize", js.undefined)
      
      inline def setMaxFiles(value: Double): Self = StObject.set(x, "maxFiles", value.asInstanceOf[js.Any])
      
      inline def setMaxFilesUndefined: Self = StObject.set(x, "maxFiles", js.undefined)
      
      inline def setMinFileSize(value: Double): Self = StObject.set(x, "minFileSize", value.asInstanceOf[js.Any])
      
      inline def setMinFileSizeUndefined: Self = StObject.set(x, "minFileSize", js.undefined)
      
      inline def setTotalFileSize(value: Double): Self = StObject.set(x, "totalFileSize", value.asInstanceOf[js.Any])
      
      inline def setTotalFileSizeUndefined: Self = StObject.set(x, "totalFileSize", js.undefined)
    }
  }
  
  /* Inlined parent std.Required<@react-md/form.@react-md/form/types/file-input/utils.FileValidationOptions> */
  trait FilesValidationOptions extends StObject {
    
    var extensions: js.Array[String]
    
    var isValidFileName: IsValidFileName_
    
    var maxFileSize: Double
    
    var maxFiles: Double
    
    var minFileSize: Double
    
    /**
      * The total number of bytes in the {@link FileUploadHookReturnValue.stats}
      * list. This is really just:
      *
      * ```ts
      * const totalBytes = stats.reduce((total, stat) => total + stat.file.size, 0);
      * ```
      */
    var totalBytes: Double
    
    var totalFileSize: Double
    
    /**
      * The total number of files in the {@link FileUploadHookReturnValue.stats}.
      */
    var totalFiles: Double
  }
  object FilesValidationOptions {
    
    inline def apply(
      extensions: js.Array[String],
      isValidFileName: (/* file */ File, /* extensionRegExp */ js.UndefOr[js.RegExp], /* extensions */ js.Array[String]) => Boolean,
      maxFileSize: Double,
      maxFiles: Double,
      minFileSize: Double,
      totalBytes: Double,
      totalFileSize: Double,
      totalFiles: Double
    ): FilesValidationOptions = {
      val __obj = js.Dynamic.literal(extensions = extensions.asInstanceOf[js.Any], isValidFileName = js.Any.fromFunction3(isValidFileName), maxFileSize = maxFileSize.asInstanceOf[js.Any], maxFiles = maxFiles.asInstanceOf[js.Any], minFileSize = minFileSize.asInstanceOf[js.Any], totalBytes = totalBytes.asInstanceOf[js.Any], totalFileSize = totalFileSize.asInstanceOf[js.Any], totalFiles = totalFiles.asInstanceOf[js.Any])
      __obj.asInstanceOf[FilesValidationOptions]
    }
    
    extension [Self <: FilesValidationOptions](x: Self) {
      
      inline def setExtensions(value: js.Array[String]): Self = StObject.set(x, "extensions", value.asInstanceOf[js.Any])
      
      inline def setExtensionsVarargs(value: String*): Self = StObject.set(x, "extensions", js.Array(value*))
      
      inline def setIsValidFileName(
        value: (/* file */ File, /* extensionRegExp */ js.UndefOr[js.RegExp], /* extensions */ js.Array[String]) => Boolean
      ): Self = StObject.set(x, "isValidFileName", js.Any.fromFunction3(value))
      
      inline def setMaxFileSize(value: Double): Self = StObject.set(x, "maxFileSize", value.asInstanceOf[js.Any])
      
      inline def setMaxFiles(value: Double): Self = StObject.set(x, "maxFiles", value.asInstanceOf[js.Any])
      
      inline def setMinFileSize(value: Double): Self = StObject.set(x, "minFileSize", value.asInstanceOf[js.Any])
      
      inline def setTotalBytes(value: Double): Self = StObject.set(x, "totalBytes", value.asInstanceOf[js.Any])
      
      inline def setTotalFileSize(value: Double): Self = StObject.set(x, "totalFileSize", value.asInstanceOf[js.Any])
      
      inline def setTotalFiles(value: Double): Self = StObject.set(x, "totalFiles", value.asInstanceOf[js.Any])
    }
  }
  
  type FilesValidator[CustomError] = js.Function2[
    /* files */ js.Array[File], 
    /* options */ FilesValidationOptions, 
    ValidatedFilesResult[CustomError]
  ]
  
  type GetFileParser_ = js.Function1[/* file */ File, FileReaderParser]
  
  type IsValidFileName_ = js.Function3[
    /* file */ File, 
    /* extensionRegExp */ js.UndefOr[js.RegExp], 
    /* extensions */ js.Array[String], 
    Boolean
  ]
  
  trait ProcessingFileUploadStats
    extends StObject
       with BaseFileUploadStats
       with FileUploadStats {
    
    var status: pending | uploading
  }
  object ProcessingFileUploadStats {
    
    inline def apply(file: File, key: String, progress: Double, status: pending | uploading): ProcessingFileUploadStats = {
      val __obj = js.Dynamic.literal(file = file.asInstanceOf[js.Any], key = key.asInstanceOf[js.Any], progress = progress.asInstanceOf[js.Any], status = status.asInstanceOf[js.Any])
      __obj.asInstanceOf[ProcessingFileUploadStats]
    }
    
    extension [Self <: ProcessingFileUploadStats](x: Self) {
      
      inline def setStatus(value: pending | uploading): Self = StObject.set(x, "status", value.asInstanceOf[js.Any])
    }
  }
  
  trait SplitFileUploads extends StObject {
    
    val complete: js.Array[CompletedFileUploadStats]
    
    val pending: js.Array[ProcessingFileUploadStats]
    
    val uploading: js.Array[ProcessingFileUploadStats]
  }
  object SplitFileUploads {
    
    inline def apply(
      complete: js.Array[CompletedFileUploadStats],
      pending: js.Array[ProcessingFileUploadStats],
      uploading: js.Array[ProcessingFileUploadStats]
    ): SplitFileUploads = {
      val __obj = js.Dynamic.literal(complete = complete.asInstanceOf[js.Any], pending = pending.asInstanceOf[js.Any], uploading = uploading.asInstanceOf[js.Any])
      __obj.asInstanceOf[SplitFileUploads]
    }
    
    extension [Self <: SplitFileUploads](x: Self) {
      
      inline def setComplete(value: js.Array[CompletedFileUploadStats]): Self = StObject.set(x, "complete", value.asInstanceOf[js.Any])
      
      inline def setCompleteVarargs(value: CompletedFileUploadStats*): Self = StObject.set(x, "complete", js.Array(value*))
      
      inline def setPending(value: js.Array[ProcessingFileUploadStats]): Self = StObject.set(x, "pending", value.asInstanceOf[js.Any])
      
      inline def setPendingVarargs(value: ProcessingFileUploadStats*): Self = StObject.set(x, "pending", js.Array(value*))
      
      inline def setUploading(value: js.Array[ProcessingFileUploadStats]): Self = StObject.set(x, "uploading", value.asInstanceOf[js.Any])
      
      inline def setUploadingVarargs(value: ProcessingFileUploadStats*): Self = StObject.set(x, "uploading", js.Array(value*))
    }
  }
  
  trait ValidatedFilesResult[CustomError] extends StObject {
    
    /**
      * A list of {@link FileValidationError} that occurred during the validation
      * step.
      *
      * Note: If an error has occurred, the file **should not** be added to the
      * {@link pending} list of files.
      */
    var errors: js.Array[FileValidationError[CustomError]]
    
    /**
      * A filtered list of files that have been validated and can be queued for the
      * upload process.
      */
    var pending: js.Array[File]
  }
  object ValidatedFilesResult {
    
    inline def apply[CustomError](errors: js.Array[FileValidationError[CustomError]], pending: js.Array[File]): ValidatedFilesResult[CustomError] = {
      val __obj = js.Dynamic.literal(errors = errors.asInstanceOf[js.Any], pending = pending.asInstanceOf[js.Any])
      __obj.asInstanceOf[ValidatedFilesResult[CustomError]]
    }
    
    extension [Self <: ValidatedFilesResult[?], CustomError](x: Self & ValidatedFilesResult[CustomError]) {
      
      inline def setErrors(value: js.Array[FileValidationError[CustomError]]): Self = StObject.set(x, "errors", value.asInstanceOf[js.Any])
      
      inline def setErrorsVarargs(value: FileValidationError[CustomError]*): Self = StObject.set(x, "errors", js.Array(value*))
      
      inline def setPending(value: js.Array[File]): Self = StObject.set(x, "pending", value.asInstanceOf[js.Any])
      
      inline def setPendingVarargs(value: File*): Self = StObject.set(x, "pending", js.Array(value*))
    }
  }
  
  trait _FileValidationError[E] extends StObject
}
