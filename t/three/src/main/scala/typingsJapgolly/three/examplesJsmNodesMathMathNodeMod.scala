package typingsJapgolly.three

import typingsJapgolly.three.threeStrings.abs
import typingsJapgolly.three.threeStrings.acos
import typingsJapgolly.three.threeStrings.asin
import typingsJapgolly.three.threeStrings.atan
import typingsJapgolly.three.threeStrings.atan2
import typingsJapgolly.three.threeStrings.ceil
import typingsJapgolly.three.threeStrings.clamp
import typingsJapgolly.three.threeStrings.cos
import typingsJapgolly.three.threeStrings.cross
import typingsJapgolly.three.threeStrings.dFdx
import typingsJapgolly.three.threeStrings.dFdy
import typingsJapgolly.three.threeStrings.degrees
import typingsJapgolly.three.threeStrings.distance
import typingsJapgolly.three.threeStrings.dot
import typingsJapgolly.three.threeStrings.exp
import typingsJapgolly.three.threeStrings.exp2
import typingsJapgolly.three.threeStrings.faceforward
import typingsJapgolly.three.threeStrings.floor
import typingsJapgolly.three.threeStrings.fract
import typingsJapgolly.three.threeStrings.inversesqrt
import typingsJapgolly.three.threeStrings.invert
import typingsJapgolly.three.threeStrings.length
import typingsJapgolly.three.threeStrings.log
import typingsJapgolly.three.threeStrings.log2
import typingsJapgolly.three.threeStrings.max
import typingsJapgolly.three.threeStrings.min
import typingsJapgolly.three.threeStrings.mix
import typingsJapgolly.three.threeStrings.negate
import typingsJapgolly.three.threeStrings.normalize
import typingsJapgolly.three.threeStrings.pow
import typingsJapgolly.three.threeStrings.radians
import typingsJapgolly.three.threeStrings.reflect
import typingsJapgolly.three.threeStrings.refract
import typingsJapgolly.three.threeStrings.round
import typingsJapgolly.three.threeStrings.saturate
import typingsJapgolly.three.threeStrings.sign
import typingsJapgolly.three.threeStrings.sin
import typingsJapgolly.three.threeStrings.smoothstep
import typingsJapgolly.three.threeStrings.sqrt
import typingsJapgolly.three.threeStrings.step
import typingsJapgolly.three.threeStrings.tan
import typingsJapgolly.three.threeStrings.transformDirection
import org.scalablytyped.runtime.StObject
import scala.scalajs.js
import scala.scalajs.js.annotation.{JSGlobalScope, JSGlobal, JSImport, JSName, JSBracketAccess}

object examplesJsmNodesMathMathNodeMod {
  
  @JSImport("three/examples/jsm/nodes/math/MathNode", JSImport.Default)
  @js.native
  open class default protected () extends MathNode {
    def this(method: MathNodeMethod1, aNode: typingsJapgolly.three.examplesJsmNodesCoreNodeMod.default) = this()
    def this(
      method: MathNodeMethod2,
      aNode: typingsJapgolly.three.examplesJsmNodesCoreNodeMod.default,
      bNode: typingsJapgolly.three.examplesJsmNodesCoreNodeMod.default
    ) = this()
    def this(
      method: MathNodeMethod3,
      aNode: typingsJapgolly.three.examplesJsmNodesCoreNodeMod.default,
      bNode: typingsJapgolly.three.examplesJsmNodesCoreNodeMod.default,
      cNode: typingsJapgolly.three.examplesJsmNodesCoreNodeMod.default
    ) = this()
  }
  /* static members */
  object default {
    
    @JSImport("three/examples/jsm/nodes/math/MathNode", JSImport.Default)
    @js.native
    val ^ : js.Any = js.native
    
    @JSImport("three/examples/jsm/nodes/math/MathNode", "default.ABS")
    @js.native
    def ABS: abs = js.native
    inline def ABS_=(x: abs): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("ABS")(x.asInstanceOf[js.Any])
    
    @JSImport("three/examples/jsm/nodes/math/MathNode", "default.ACOS")
    @js.native
    def ACOS: acos = js.native
    inline def ACOS_=(x: acos): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("ACOS")(x.asInstanceOf[js.Any])
    
    @JSImport("three/examples/jsm/nodes/math/MathNode", "default.ASIN")
    @js.native
    def ASIN: asin = js.native
    inline def ASIN_=(x: asin): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("ASIN")(x.asInstanceOf[js.Any])
    
    @JSImport("three/examples/jsm/nodes/math/MathNode", "default.ATAN")
    @js.native
    def ATAN: atan = js.native
    
    // 2 inputs
    @JSImport("three/examples/jsm/nodes/math/MathNode", "default.ATAN2")
    @js.native
    def ATAN2: atan2 = js.native
    inline def ATAN2_=(x: atan2): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("ATAN2")(x.asInstanceOf[js.Any])
    
    inline def ATAN_=(x: atan): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("ATAN")(x.asInstanceOf[js.Any])
    
    @JSImport("three/examples/jsm/nodes/math/MathNode", "default.CEIL")
    @js.native
    def CEIL: ceil = js.native
    inline def CEIL_=(x: ceil): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("CEIL")(x.asInstanceOf[js.Any])
    
    @JSImport("three/examples/jsm/nodes/math/MathNode", "default.CLAMP")
    @js.native
    def CLAMP: clamp = js.native
    inline def CLAMP_=(x: clamp): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("CLAMP")(x.asInstanceOf[js.Any])
    
    @JSImport("three/examples/jsm/nodes/math/MathNode", "default.COS")
    @js.native
    def COS: cos = js.native
    inline def COS_=(x: cos): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("COS")(x.asInstanceOf[js.Any])
    
    @JSImport("three/examples/jsm/nodes/math/MathNode", "default.CROSS")
    @js.native
    def CROSS: cross = js.native
    inline def CROSS_=(x: cross): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("CROSS")(x.asInstanceOf[js.Any])
    
    @JSImport("three/examples/jsm/nodes/math/MathNode", "default.DEGREES")
    @js.native
    def DEGREES: degrees = js.native
    inline def DEGREES_=(x: degrees): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("DEGREES")(x.asInstanceOf[js.Any])
    
    @JSImport("three/examples/jsm/nodes/math/MathNode", "default.DFDX")
    @js.native
    def DFDX: dFdx = js.native
    inline def DFDX_=(x: dFdx): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("DFDX")(x.asInstanceOf[js.Any])
    
    @JSImport("three/examples/jsm/nodes/math/MathNode", "default.DFDY")
    @js.native
    def DFDY: dFdy = js.native
    inline def DFDY_=(x: dFdy): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("DFDY")(x.asInstanceOf[js.Any])
    
    @JSImport("three/examples/jsm/nodes/math/MathNode", "default.DISTANCE")
    @js.native
    def DISTANCE: distance = js.native
    inline def DISTANCE_=(x: distance): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("DISTANCE")(x.asInstanceOf[js.Any])
    
    @JSImport("three/examples/jsm/nodes/math/MathNode", "default.DOT")
    @js.native
    def DOT: dot = js.native
    inline def DOT_=(x: dot): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("DOT")(x.asInstanceOf[js.Any])
    
    @JSImport("three/examples/jsm/nodes/math/MathNode", "default.EXP")
    @js.native
    def EXP: exp = js.native
    
    @JSImport("three/examples/jsm/nodes/math/MathNode", "default.EXP2")
    @js.native
    def EXP2: exp2 = js.native
    inline def EXP2_=(x: exp2): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("EXP2")(x.asInstanceOf[js.Any])
    
    inline def EXP_=(x: exp): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("EXP")(x.asInstanceOf[js.Any])
    
    @JSImport("three/examples/jsm/nodes/math/MathNode", "default.FACEFORWARD")
    @js.native
    def FACEFORWARD: faceforward = js.native
    inline def FACEFORWARD_=(x: faceforward): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("FACEFORWARD")(x.asInstanceOf[js.Any])
    
    @JSImport("three/examples/jsm/nodes/math/MathNode", "default.FLOOR")
    @js.native
    def FLOOR: floor = js.native
    inline def FLOOR_=(x: floor): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("FLOOR")(x.asInstanceOf[js.Any])
    
    @JSImport("three/examples/jsm/nodes/math/MathNode", "default.FRACT")
    @js.native
    def FRACT: fract = js.native
    inline def FRACT_=(x: fract): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("FRACT")(x.asInstanceOf[js.Any])
    
    @JSImport("three/examples/jsm/nodes/math/MathNode", "default.INVERSE_SQRT")
    @js.native
    def INVERSE_SQRT: inversesqrt = js.native
    inline def INVERSE_SQRT_=(x: inversesqrt): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("INVERSE_SQRT")(x.asInstanceOf[js.Any])
    
    @JSImport("three/examples/jsm/nodes/math/MathNode", "default.INVERT")
    @js.native
    def INVERT: invert = js.native
    inline def INVERT_=(x: invert): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("INVERT")(x.asInstanceOf[js.Any])
    
    @JSImport("three/examples/jsm/nodes/math/MathNode", "default.LENGTH")
    @js.native
    def LENGTH: length = js.native
    inline def LENGTH_=(x: length): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("LENGTH")(x.asInstanceOf[js.Any])
    
    @JSImport("three/examples/jsm/nodes/math/MathNode", "default.LOG")
    @js.native
    def LOG: log = js.native
    
    @JSImport("three/examples/jsm/nodes/math/MathNode", "default.LOG2")
    @js.native
    def LOG2: log2 = js.native
    inline def LOG2_=(x: log2): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("LOG2")(x.asInstanceOf[js.Any])
    
    inline def LOG_=(x: log): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("LOG")(x.asInstanceOf[js.Any])
    
    @JSImport("three/examples/jsm/nodes/math/MathNode", "default.MAX")
    @js.native
    def MAX: max = js.native
    inline def MAX_=(x: max): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("MAX")(x.asInstanceOf[js.Any])
    
    @JSImport("three/examples/jsm/nodes/math/MathNode", "default.MIN")
    @js.native
    def MIN: min = js.native
    inline def MIN_=(x: min): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("MIN")(x.asInstanceOf[js.Any])
    
    // 3 inputs
    @JSImport("three/examples/jsm/nodes/math/MathNode", "default.MIX")
    @js.native
    def MIX: mix = js.native
    inline def MIX_=(x: mix): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("MIX")(x.asInstanceOf[js.Any])
    
    @JSImport("three/examples/jsm/nodes/math/MathNode", "default.MOD")
    @js.native
    def MOD: typingsJapgolly.three.threeStrings.mod = js.native
    inline def MOD_=(x: typingsJapgolly.three.threeStrings.mod): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("MOD")(x.asInstanceOf[js.Any])
    
    @JSImport("three/examples/jsm/nodes/math/MathNode", "default.NEGATE")
    @js.native
    def NEGATE: negate = js.native
    inline def NEGATE_=(x: negate): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("NEGATE")(x.asInstanceOf[js.Any])
    
    @JSImport("three/examples/jsm/nodes/math/MathNode", "default.NORMALIZE")
    @js.native
    def NORMALIZE: normalize = js.native
    inline def NORMALIZE_=(x: normalize): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("NORMALIZE")(x.asInstanceOf[js.Any])
    
    @JSImport("three/examples/jsm/nodes/math/MathNode", "default.POW")
    @js.native
    def POW: pow = js.native
    inline def POW_=(x: pow): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("POW")(x.asInstanceOf[js.Any])
    
    // 1 input
    @JSImport("three/examples/jsm/nodes/math/MathNode", "default.RADIANS")
    @js.native
    def RADIANS: radians = js.native
    inline def RADIANS_=(x: radians): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("RADIANS")(x.asInstanceOf[js.Any])
    
    @JSImport("three/examples/jsm/nodes/math/MathNode", "default.REFLECT")
    @js.native
    def REFLECT: reflect = js.native
    inline def REFLECT_=(x: reflect): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("REFLECT")(x.asInstanceOf[js.Any])
    
    @JSImport("three/examples/jsm/nodes/math/MathNode", "default.REFRACT")
    @js.native
    def REFRACT: refract = js.native
    inline def REFRACT_=(x: refract): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("REFRACT")(x.asInstanceOf[js.Any])
    
    @JSImport("three/examples/jsm/nodes/math/MathNode", "default.ROUND")
    @js.native
    def ROUND: round = js.native
    inline def ROUND_=(x: round): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("ROUND")(x.asInstanceOf[js.Any])
    
    @JSImport("three/examples/jsm/nodes/math/MathNode", "default.SATURATE")
    @js.native
    def SATURATE: saturate = js.native
    inline def SATURATE_=(x: saturate): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("SATURATE")(x.asInstanceOf[js.Any])
    
    @JSImport("three/examples/jsm/nodes/math/MathNode", "default.SIGN")
    @js.native
    def SIGN: sign = js.native
    inline def SIGN_=(x: sign): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("SIGN")(x.asInstanceOf[js.Any])
    
    @JSImport("three/examples/jsm/nodes/math/MathNode", "default.SIN")
    @js.native
    def SIN: sin = js.native
    inline def SIN_=(x: sin): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("SIN")(x.asInstanceOf[js.Any])
    
    @JSImport("three/examples/jsm/nodes/math/MathNode", "default.SMOOTHSTEP")
    @js.native
    def SMOOTHSTEP: smoothstep = js.native
    inline def SMOOTHSTEP_=(x: smoothstep): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("SMOOTHSTEP")(x.asInstanceOf[js.Any])
    
    @JSImport("three/examples/jsm/nodes/math/MathNode", "default.SQRT")
    @js.native
    def SQRT: sqrt = js.native
    inline def SQRT_=(x: sqrt): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("SQRT")(x.asInstanceOf[js.Any])
    
    @JSImport("three/examples/jsm/nodes/math/MathNode", "default.STEP")
    @js.native
    def STEP: step = js.native
    inline def STEP_=(x: step): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("STEP")(x.asInstanceOf[js.Any])
    
    @JSImport("three/examples/jsm/nodes/math/MathNode", "default.TAN")
    @js.native
    def TAN: tan = js.native
    inline def TAN_=(x: tan): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("TAN")(x.asInstanceOf[js.Any])
    
    @JSImport("three/examples/jsm/nodes/math/MathNode", "default.TRANSFORM_DIRECTION")
    @js.native
    def TRANSFORM_DIRECTION: transformDirection = js.native
    inline def TRANSFORM_DIRECTION_=(x: transformDirection): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("TRANSFORM_DIRECTION")(x.asInstanceOf[js.Any])
  }
  
  @js.native
  trait MathNode
    extends typingsJapgolly.three.examplesJsmNodesCoreTempNodeMod.default {
    
    var aNode: typingsJapgolly.three.examplesJsmNodesCoreNodeMod.default = js.native
    
    var bNode: typingsJapgolly.three.examplesJsmNodesCoreNodeMod.default | Null = js.native
    
    var cNode: typingsJapgolly.three.examplesJsmNodesCoreNodeMod.default | Null = js.native
    
    var method: MathNodeMethod = js.native
  }
  
  type MathNodeMethod = MathNodeMethod1 | MathNodeMethod2 | MathNodeMethod3
  
  type MathNodeMethod1 = /* import warning: ResolveTypeQueries.resolve Couldn't resolve typeof MathNode.RADIANS */ Any
  
  type MathNodeMethod2 = /* import warning: ResolveTypeQueries.resolve Couldn't resolve typeof MathNode.ATAN2 */ Any
  
  type MathNodeMethod3 = /* import warning: ResolveTypeQueries.resolve Couldn't resolve typeof MathNode.MIX */ Any
}
