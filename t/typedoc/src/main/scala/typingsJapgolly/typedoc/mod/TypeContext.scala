package typingsJapgolly.typedoc.mod

import org.scalablytyped.runtime.StObject
import scala.scalajs.js
import scala.scalajs.js.annotation.{JSGlobalScope, JSGlobal, JSImport, JSName, JSBracketAccess}

object TypeContext {
  
  @JSImport("typedoc", "TypeContext.arrayElement")
  @js.native
  val arrayElement: typingsJapgolly.typedoc.typedocStrings.arrayElement = js.native
  
  @JSImport("typedoc", "TypeContext.conditionalCheck")
  @js.native
  val conditionalCheck: typingsJapgolly.typedoc.typedocStrings.conditionalCheck = js.native
  
  @JSImport("typedoc", "TypeContext.conditionalExtends")
  @js.native
  val conditionalExtends: typingsJapgolly.typedoc.typedocStrings.conditionalExtends = js.native
  
  @JSImport("typedoc", "TypeContext.conditionalFalse")
  @js.native
  val conditionalFalse: typingsJapgolly.typedoc.typedocStrings.conditionalFalse = js.native
  
  @JSImport("typedoc", "TypeContext.conditionalTrue")
  @js.native
  val conditionalTrue: typingsJapgolly.typedoc.typedocStrings.conditionalTrue = js.native
  
  @JSImport("typedoc", "TypeContext.indexedAccessElement")
  @js.native
  val indexedAccessElement: typingsJapgolly.typedoc.typedocStrings.indexedAccessElement = js.native
  
  @JSImport("typedoc", "TypeContext.indexedIndex")
  @js.native
  val indexedIndex: typingsJapgolly.typedoc.typedocStrings.indexedIndex = js.native
  
  @JSImport("typedoc", "TypeContext.indexedObject")
  @js.native
  val indexedObject: typingsJapgolly.typedoc.typedocStrings.indexedObject = js.native
  
  @JSImport("typedoc", "TypeContext.inferredConstraint")
  @js.native
  val inferredConstraint: typingsJapgolly.typedoc.typedocStrings.inferredConstraint = js.native
  
  @JSImport("typedoc", "TypeContext.intersectionElement")
  @js.native
  val intersectionElement: typingsJapgolly.typedoc.typedocStrings.intersectionElement = js.native
  
  @JSImport("typedoc", "TypeContext.mappedName")
  @js.native
  val mappedName: typingsJapgolly.typedoc.typedocStrings.mappedName = js.native
  
  @JSImport("typedoc", "TypeContext.mappedParameter")
  @js.native
  val mappedParameter: typingsJapgolly.typedoc.typedocStrings.mappedParameter = js.native
  
  @JSImport("typedoc", "TypeContext.mappedTemplate")
  @js.native
  val mappedTemplate: typingsJapgolly.typedoc.typedocStrings.mappedTemplate = js.native
  
  @JSImport("typedoc", "TypeContext.none")
  @js.native
  val none: typingsJapgolly.typedoc.typedocStrings.none = js.native
  
  @JSImport("typedoc", "TypeContext.optionalElement")
  @js.native
  val optionalElement: typingsJapgolly.typedoc.typedocStrings.optionalElement = js.native
  
  @JSImport("typedoc", "TypeContext.predicateTarget")
  @js.native
  val predicateTarget: typingsJapgolly.typedoc.typedocStrings.predicateTarget = js.native
  
  @JSImport("typedoc", "TypeContext.queryTypeTarget")
  @js.native
  val queryTypeTarget: typingsJapgolly.typedoc.typedocStrings.queryTypeTarget = js.native
  
  @JSImport("typedoc", "TypeContext.referenceTypeArgument")
  @js.native
  val referenceTypeArgument: typingsJapgolly.typedoc.typedocStrings.referenceTypeArgument = js.native
  
  @JSImport("typedoc", "TypeContext.restElement")
  @js.native
  val restElement: typingsJapgolly.typedoc.typedocStrings.restElement = js.native
  
  @JSImport("typedoc", "TypeContext.templateLiteralElement")
  @js.native
  val templateLiteralElement: typingsJapgolly.typedoc.typedocStrings.templateLiteralElement = js.native
  
  @JSImport("typedoc", "TypeContext.tupleElement")
  @js.native
  val tupleElement: typingsJapgolly.typedoc.typedocStrings.tupleElement = js.native
  
  @JSImport("typedoc", "TypeContext.typeOperatorTarget")
  @js.native
  val typeOperatorTarget: typingsJapgolly.typedoc.typedocStrings.typeOperatorTarget = js.native
  
  @JSImport("typedoc", "TypeContext.unionElement")
  @js.native
  val unionElement: typingsJapgolly.typedoc.typedocStrings.unionElement = js.native
}
