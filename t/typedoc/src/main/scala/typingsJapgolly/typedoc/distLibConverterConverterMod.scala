package typingsJapgolly.typedoc

import typingsJapgolly.std.Record
import typingsJapgolly.typedoc.distLibApplicationMod.Application
import typingsJapgolly.typedoc.distLibConverterCommentsDeclarationReferenceMod.DeclarationReference
import typingsJapgolly.typedoc.distLibConverterCommentsMod.CommentParserConfig
import typingsJapgolly.typedoc.distLibConverterComponentsMod.ConverterComponent
import typingsJapgolly.typedoc.distLibConverterContextMod.Context
import typingsJapgolly.typedoc.distLibModelsCommentsCommentMod.CommentDisplayPart
import typingsJapgolly.typedoc.distLibModelsMod.Comment
import typingsJapgolly.typedoc.distLibModelsMod.ProjectReflection
import typingsJapgolly.typedoc.distLibModelsMod.Reflection
import typingsJapgolly.typedoc.distLibModelsTypesMod.SomeType
import typingsJapgolly.typedoc.distLibUtilsComponentMod.ChildableComponent
import typingsJapgolly.typedoc.distLibUtilsEntryPointMod.DocumentationEntryPoint
import typingsJapgolly.typedoc.distLibUtilsMod.MinimalSourceFile
import typingsJapgolly.typedoc.distLibUtilsOptionsDeclarationMod.CommentStyle
import typingsJapgolly.typedoc.distLibUtilsOptionsDeclarationMod.ValidationOptions
import typingsJapgolly.typedoc.typedocStrings.begin
import typingsJapgolly.typedoc.typedocStrings.createDeclaration
import typingsJapgolly.typedoc.typedocStrings.createParameter
import typingsJapgolly.typedoc.typedocStrings.createSignature
import typingsJapgolly.typedoc.typedocStrings.createTypeParameter
import typingsJapgolly.typedoc.typedocStrings.end
import typingsJapgolly.typedoc.typedocStrings.resolveBegin
import typingsJapgolly.typedoc.typedocStrings.resolveEnd
import typingsJapgolly.typedoc.typedocStrings.resolveReflection
import typingsJapgolly.typescript.mod.Symbol
import typingsJapgolly.typescript.mod.Type
import typingsJapgolly.typescript.mod.TypeNode
import org.scalablytyped.runtime.StObject
import scala.scalajs.js
import scala.scalajs.js.annotation.{JSGlobalScope, JSGlobal, JSImport, JSName, JSBracketAccess}

object distLibConverterConverterMod {
  
  @JSImport("typedoc/dist/lib/converter/converter", "Converter")
  @js.native
  open class Converter protected () extends ChildableComponent[Application, ConverterComponent] {
    def this(owner: Application) = this()
    
    /* private */ var _buildCommentParserConfig: Any = js.native
    
    /* private */ var _config: Any = js.native
    
    /* private */ var _externalSymbolResolvers: Any = js.native
    
    /**
      * Adds a new resolver that the theme can use to try to figure out how to link to a symbol declared
      * by a third-party library which is not included in the documentation.
      *
      * The resolver function will be passed a declaration reference which it can attempt to resolve. If
      * resolution fails, the function should return undefined.
      *
      * Note: This will be used for both references to types declared in node_modules (in which case the
      * reference passed will have the `moduleSource` set and the `symbolReference` will navigate via `.`)
      * and user defined \{\@link\} tags which cannot be resolved.
      * @since 0.22.14
      */
    def addUnknownSymbolResolver(resolver: js.Function1[/* ref */ DeclarationReference, js.UndefOr[String]]): Unit = js.native
    
    /** @internal */
    var commentStyle: CommentStyle = js.native
    
    /**
      * Compile the files within the given context and convert the compiler symbols to reflections.
      *
      * @param context  The context object describing the current state the converter is in.
      * @returns An array containing all errors generated by the TypeScript compiler.
      */
    /* private */ var compile: Any = js.native
    
    def config: CommentParserConfig = js.native
    
    /**
      * Compile the given source files and create a project reflection for them.
      */
    def convert(entryPoints: js.Array[DocumentationEntryPoint]): ProjectReflection = js.native
    
    /* private */ var convertExports: Any = js.native
    
    /* private */ var convertReExports: Any = js.native
    
    /** @internal */
    def convertSymbol(context: Context, symbol: Symbol): Unit = js.native
    def convertSymbol(context: Context, symbol: Symbol, exportSymbol: Symbol): Unit = js.native
    
    /**
      * Convert the given TypeScript type into its TypeDoc type reflection.
      *
      * @param context  The context object describing the current state the converter is in.
      * @param referenceTarget The target to be used to attempt to resolve reference types
      * @returns The TypeDoc type reflection representing the given node and type.
      * @internal
      */
    def convertType(context: Context): SomeType = js.native
    def convertType(context: Context, node: Type): SomeType = js.native
    def convertType(context: Context, node: TypeNode): SomeType = js.native
    
    /* private */ var excludeCache: Any = js.native
    
    /** @internal */
    var excludeExternals: Boolean = js.native
    
    /** @internal */
    var excludeNotDocumented: Boolean = js.native
    
    /** @internal */
    var excludePrivate: Boolean = js.native
    
    /** @internal */
    var excludeProtected: Boolean = js.native
    
    /** @internal */
    var externalPattern: js.Array[String] = js.native
    
    /* private */ var externalPatternCache: Any = js.native
    
    /** @internal */
    var externalSymbolLinkMappings: Record[String, Record[String, String]] = js.native
    
    /* private */ var isExcluded: Any = js.native
    
    /** @internal */
    def isExternal(symbol: Symbol): Boolean = js.native
    
    /**
      * Parse the given file into a comment. Intended to be used with markdown files.
      */
    def parseRawComment(file: MinimalSourceFile): Comment = js.native
    
    /**
      * Resolve the project within the given context.
      *
      * @param context  The context object describing the current state the converter is in.
      * @returns The final project reflection.
      */
    /* private */ var resolve: Any = js.native
    
    /** @internal */
    def resolveExternalLink(ref: DeclarationReference): js.UndefOr[String] = js.native
    
    def resolveLinks(comment: Comment, owner: Reflection): Unit = js.native
    def resolveLinks(parts: js.Array[CommentDisplayPart], owner: Reflection): js.Array[CommentDisplayPart] = js.native
    
    /**
      * Used to determine if we should immediately bail when creating a reflection.
      * Note: This should not be used for excludeNotDocumented because we don't have enough
      * information at this point since comment discovery hasn't happened.
      * @internal
      */
    def shouldIgnore(symbol: Symbol): Boolean = js.native
    
    /** @internal */
    var validation: ValidationOptions = js.native
  }
  /* static members */
  object Converter {
    
    /**
      * General events
      */
    /**
      * Triggered when the converter begins converting a project.
      * The listener will be given a {@link Context} object.
      * @event
      */
    @JSImport("typedoc/dist/lib/converter/converter", "Converter.EVENT_BEGIN")
    @js.native
    val EVENT_BEGIN: begin = js.native
    
    /**
      * Factory events
      */
    /**
      * Triggered when the converter has created a declaration reflection.
      * The listener will be given {@link Context} and a {@link DeclarationReflection}.
      * @event
      */
    @JSImport("typedoc/dist/lib/converter/converter", "Converter.EVENT_CREATE_DECLARATION")
    @js.native
    val EVENT_CREATE_DECLARATION: createDeclaration = js.native
    
    /**
      * Triggered when the converter has created a parameter reflection.
      * The listener will be given {@link Context}, {@link ParameterReflection} and a `ts.Node?`
      * @event
      */
    @JSImport("typedoc/dist/lib/converter/converter", "Converter.EVENT_CREATE_PARAMETER")
    @js.native
    val EVENT_CREATE_PARAMETER: createParameter = js.native
    
    /**
      * Triggered when the converter has created a signature reflection.
      * The listener will be given {@link Context}, {@link SignatureReflection} | {@link ProjectReflection} and
      * `ts.SignatureDeclaration | ts.IndexSignatureDeclaration | ts.JSDocSignature | undefined`
      * @event
      */
    @JSImport("typedoc/dist/lib/converter/converter", "Converter.EVENT_CREATE_SIGNATURE")
    @js.native
    val EVENT_CREATE_SIGNATURE: createSignature = js.native
    
    /**
      * Triggered when the converter has created a type parameter reflection.
      * The listener will be given {@link Context} and a {@link TypeParameterReflection}
      * @event
      */
    @JSImport("typedoc/dist/lib/converter/converter", "Converter.EVENT_CREATE_TYPE_PARAMETER")
    @js.native
    val EVENT_CREATE_TYPE_PARAMETER: createTypeParameter = js.native
    
    /**
      * Triggered when the converter has finished converting a project.
      * The listener will be given a {@link Context} object.
      * @event
      */
    @JSImport("typedoc/dist/lib/converter/converter", "Converter.EVENT_END")
    @js.native
    val EVENT_END: end = js.native
    
    /**
      * Triggered when the converter resolves a reflection.
      * The listener will be given {@link Context} and a {@link Reflection}.
      * @event
      */
    @JSImport("typedoc/dist/lib/converter/converter", "Converter.EVENT_RESOLVE")
    @js.native
    val EVENT_RESOLVE: resolveReflection = js.native
    
    /**
      * Resolve events
      */
    /**
      * Triggered when the converter begins resolving a project.
      * The listener will be given {@link Context}.
      * @event
      */
    @JSImport("typedoc/dist/lib/converter/converter", "Converter.EVENT_RESOLVE_BEGIN")
    @js.native
    val EVENT_RESOLVE_BEGIN: resolveBegin = js.native
    
    /**
      * Triggered when the converter has finished resolving a project.
      * The listener will be given {@link Context}.
      * @event
      */
    @JSImport("typedoc/dist/lib/converter/converter", "Converter.EVENT_RESOLVE_END")
    @js.native
    val EVENT_RESOLVE_END: resolveEnd = js.native
  }
}
