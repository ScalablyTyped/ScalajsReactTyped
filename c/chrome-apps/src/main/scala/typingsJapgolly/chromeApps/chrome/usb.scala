package typingsJapgolly.chromeApps.chrome

import typingsJapgolly.chromeApps.anon.ADAPTIVE
import typingsJapgolly.chromeApps.anon.BULK
import typingsJapgolly.chromeApps.anon.CLASS
import typingsJapgolly.chromeApps.anon.DATA_
import typingsJapgolly.chromeApps.anon.DEVICE
import typingsJapgolly.chromeApps.anon.IN
import typingsJapgolly.chromeApps.chrome.events.Event
import typingsJapgolly.chromeApps.chromeAppsStrings.ASYNCHRONOUS
import typingsJapgolly.chromeApps.chromeAppsStrings.CONTROL
import typingsJapgolly.chromeApps.chromeAppsStrings.DATA
import typingsJapgolly.chromeApps.chromeAppsStrings.ENDPOINT
import typingsJapgolly.chromeApps.chromeAppsStrings.EXPLICIT_FEEDBACK
import typingsJapgolly.chromeApps.chromeAppsStrings.FEEDBACK
import typingsJapgolly.chromeApps.chromeAppsStrings.INTERFACE
import typingsJapgolly.chromeApps.chromeAppsStrings.INTERRUPT
import typingsJapgolly.chromeApps.chromeAppsStrings.ISOCHRONOUS
import typingsJapgolly.chromeApps.chromeAppsStrings.NOTIFICATION
import typingsJapgolly.chromeApps.chromeAppsStrings.OTHER
import typingsJapgolly.chromeApps.chromeAppsStrings.OUT
import typingsJapgolly.chromeApps.chromeAppsStrings.PERIODIC
import typingsJapgolly.chromeApps.chromeAppsStrings.RESERVED
import typingsJapgolly.chromeApps.chromeAppsStrings.STANDARD
import typingsJapgolly.chromeApps.chromeAppsStrings.SYNCHRONOUS
import typingsJapgolly.chromeApps.chromeAppsStrings.VENDOR
import org.scalablytyped.runtime.StObject
import scala.scalajs.js
import scala.scalajs.js.annotation.{JSGlobalScope, JSGlobal, JSImport, JSName, JSBracketAccess}

// #endregion
// #region chrome.usb
/////////
// USB //
/////////
/**
  * @requires Permissions: 'usb'
  * @since Chrome 26.
  * Use the chrome.usb API to interact with connected USB devices.
  * This API provides access to USB operations from within the context of an app.
  * Using this API, apps can function as drivers for hardware devices.
  * Errors generated by this API are reported by setting runtime.lastError
  * and executing the function's regular callback. The callback's
  * regular parameters will be undefined in this case.
  * @see[Accessing Hardware Devices]{@link https://developer.chrome.com/apps/app_usb}
  */
object usb {
  
  /** @since Chrome 39. */
  trait ConfigDescriptor extends StObject {
    
    /**
      * Is this the active configuration?
      * @since Chrome 47.
      */
    var active: Boolean
    
    /** The configuration number. */
    var configurationValue: integer
    
    /** Description of the configuration. */
    var description: js.UndefOr[String] = js.undefined
    
    /** Extra descriptor data associated with this configuration. */
    var extra_data: js.typedarray.ArrayBuffer
    
    /** Available interfaces. */
    var interfaces: js.Array[InterfaceDescriptor]
    
    /** The maximum power needed by this device in milliamps (mA). */
    var maxPower: integer
    
    /** The device supports remote wakeup. */
    var remoteWakeup: Boolean
    
    /** The device is self-powered. */
    var selfPowered: Boolean
  }
  object ConfigDescriptor {
    
    inline def apply(
      active: Boolean,
      configurationValue: integer,
      extra_data: js.typedarray.ArrayBuffer,
      interfaces: js.Array[InterfaceDescriptor],
      maxPower: integer,
      remoteWakeup: Boolean,
      selfPowered: Boolean
    ): ConfigDescriptor = {
      val __obj = js.Dynamic.literal(active = active.asInstanceOf[js.Any], configurationValue = configurationValue.asInstanceOf[js.Any], extra_data = extra_data.asInstanceOf[js.Any], interfaces = interfaces.asInstanceOf[js.Any], maxPower = maxPower.asInstanceOf[js.Any], remoteWakeup = remoteWakeup.asInstanceOf[js.Any], selfPowered = selfPowered.asInstanceOf[js.Any])
      __obj.asInstanceOf[ConfigDescriptor]
    }
    
    extension [Self <: ConfigDescriptor](x: Self) {
      
      inline def setActive(value: Boolean): Self = StObject.set(x, "active", value.asInstanceOf[js.Any])
      
      inline def setConfigurationValue(value: integer): Self = StObject.set(x, "configurationValue", value.asInstanceOf[js.Any])
      
      inline def setDescription(value: String): Self = StObject.set(x, "description", value.asInstanceOf[js.Any])
      
      inline def setDescriptionUndefined: Self = StObject.set(x, "description", js.undefined)
      
      inline def setExtra_data(value: js.typedarray.ArrayBuffer): Self = StObject.set(x, "extra_data", value.asInstanceOf[js.Any])
      
      inline def setInterfaces(value: js.Array[InterfaceDescriptor]): Self = StObject.set(x, "interfaces", value.asInstanceOf[js.Any])
      
      inline def setInterfacesVarargs(value: InterfaceDescriptor*): Self = StObject.set(x, "interfaces", js.Array(value*))
      
      inline def setMaxPower(value: integer): Self = StObject.set(x, "maxPower", value.asInstanceOf[js.Any])
      
      inline def setRemoteWakeup(value: Boolean): Self = StObject.set(x, "remoteWakeup", value.asInstanceOf[js.Any])
      
      inline def setSelfPowered(value: Boolean): Self = StObject.set(x, "selfPowered", value.asInstanceOf[js.Any])
    }
  }
  
  /** Since Chrome 31. */
  trait ConnectionHandle extends StObject {
    
    /**
      * An opaque handle representing this connection to the USB device
      * and all associated claimed interfaces and pending transfers.
      * A new handle is created each time the device is opened.
      * The connection handle is different from Device.device.
      */
    var handle: integer
    
    /** The product ID. */
    var productId: integer
    
    /** The device vendor ID. */
    var vendorId: integer
  }
  object ConnectionHandle {
    
    inline def apply(handle: integer, productId: integer, vendorId: integer): ConnectionHandle = {
      val __obj = js.Dynamic.literal(handle = handle.asInstanceOf[js.Any], productId = productId.asInstanceOf[js.Any], vendorId = vendorId.asInstanceOf[js.Any])
      __obj.asInstanceOf[ConnectionHandle]
    }
    
    extension [Self <: ConnectionHandle](x: Self) {
      
      inline def setHandle(value: integer): Self = StObject.set(x, "handle", value.asInstanceOf[js.Any])
      
      inline def setProductId(value: integer): Self = StObject.set(x, "productId", value.asInstanceOf[js.Any])
      
      inline def setVendorId(value: integer): Self = StObject.set(x, "vendorId", value.asInstanceOf[js.Any])
    }
  }
  
  trait Device extends StObject {
    
    /**
      * An opaque ID for the USB device. It remains unchanged until the device is unplugged.
      * @since Chrome 31.
      */
    var device: integer
    
    /**
      * The iManufacturer string read from the device, if available.
      * @since Chrome 46.
      */
    var manufacturerName: String
    
    /** The product ID. */
    var productId: integer
    
    /**
      * The iProduct string read from the device, if available.
      * @since Chrome 46.
      */
    var productName: String
    
    /**
      * The iSerialNumber string read from the device, if available.
      * @since Chrome 46.
      */
    var serialNumber: String
    
    /** The vendor ID. */
    var vendorId: integer
    
    /**
      * The device version (bcdDevice field).
      * @since Chrome 46.
      */
    var version: integer
  }
  object Device {
    
    inline def apply(
      device: integer,
      manufacturerName: String,
      productId: integer,
      productName: String,
      serialNumber: String,
      vendorId: integer,
      version: integer
    ): Device = {
      val __obj = js.Dynamic.literal(device = device.asInstanceOf[js.Any], manufacturerName = manufacturerName.asInstanceOf[js.Any], productId = productId.asInstanceOf[js.Any], productName = productName.asInstanceOf[js.Any], serialNumber = serialNumber.asInstanceOf[js.Any], vendorId = vendorId.asInstanceOf[js.Any], version = version.asInstanceOf[js.Any])
      __obj.asInstanceOf[Device]
    }
    
    extension [Self <: Device](x: Self) {
      
      inline def setDevice(value: integer): Self = StObject.set(x, "device", value.asInstanceOf[js.Any])
      
      inline def setManufacturerName(value: String): Self = StObject.set(x, "manufacturerName", value.asInstanceOf[js.Any])
      
      inline def setProductId(value: integer): Self = StObject.set(x, "productId", value.asInstanceOf[js.Any])
      
      inline def setProductName(value: String): Self = StObject.set(x, "productName", value.asInstanceOf[js.Any])
      
      inline def setSerialNumber(value: String): Self = StObject.set(x, "serialNumber", value.asInstanceOf[js.Any])
      
      inline def setVendorId(value: integer): Self = StObject.set(x, "vendorId", value.asInstanceOf[js.Any])
      
      inline def setVersion(value: integer): Self = StObject.set(x, "version", value.asInstanceOf[js.Any])
    }
  }
  
  type DeviceEvent = Event[js.Function1[/* device */ Device, Unit]]
  
  /** @since Chrome 39. */
  /* Inlined parent std.Partial<chrome-apps.chrome.usb.DeviceFilterStrict> */
  trait DeviceFilter extends StObject {
    
    var interfaceClass: js.UndefOr[integer] = js.undefined
    
    var interfaceProtocol: js.UndefOr[integer] = js.undefined
    
    var interfaceSubclass: js.UndefOr[integer] = js.undefined
    
    var productId: js.UndefOr[integer] = js.undefined
    
    var vendorId: js.UndefOr[integer] = js.undefined
  }
  object DeviceFilter {
    
    inline def apply(): DeviceFilter = {
      val __obj = js.Dynamic.literal()
      __obj.asInstanceOf[DeviceFilter]
    }
    
    extension [Self <: DeviceFilter](x: Self) {
      
      inline def setInterfaceClass(value: integer): Self = StObject.set(x, "interfaceClass", value.asInstanceOf[js.Any])
      
      inline def setInterfaceClassUndefined: Self = StObject.set(x, "interfaceClass", js.undefined)
      
      inline def setInterfaceProtocol(value: integer): Self = StObject.set(x, "interfaceProtocol", value.asInstanceOf[js.Any])
      
      inline def setInterfaceProtocolUndefined: Self = StObject.set(x, "interfaceProtocol", js.undefined)
      
      inline def setInterfaceSubclass(value: integer): Self = StObject.set(x, "interfaceSubclass", value.asInstanceOf[js.Any])
      
      inline def setInterfaceSubclassUndefined: Self = StObject.set(x, "interfaceSubclass", js.undefined)
      
      inline def setProductId(value: integer): Self = StObject.set(x, "productId", value.asInstanceOf[js.Any])
      
      inline def setProductIdUndefined: Self = StObject.set(x, "productId", js.undefined)
      
      inline def setVendorId(value: integer): Self = StObject.set(x, "vendorId", value.asInstanceOf[js.Any])
      
      inline def setVendorIdUndefined: Self = StObject.set(x, "vendorId", js.undefined)
    }
  }
  
  trait DeviceFilterStrict extends StObject {
    
    /** USB interface class, matches any interface on the device. */
    var interfaceClass: js.UndefOr[integer] = js.undefined
    
    /** USB interface protocol, checked only if the interface sub-class matches. */
    var interfaceProtocol: js.UndefOr[integer] = js.undefined
    
    /** USB interface sub-class, checked only if the interface class matches. */
    var interfaceSubclass: js.UndefOr[integer] = js.undefined
    
    /** Device product ID, checked only if the vendor ID matches. */
    var productId: js.UndefOr[integer] = js.undefined
    
    /** Device vendor ID. */
    var vendorId: integer
  }
  object DeviceFilterStrict {
    
    inline def apply(vendorId: integer): DeviceFilterStrict = {
      val __obj = js.Dynamic.literal(vendorId = vendorId.asInstanceOf[js.Any])
      __obj.asInstanceOf[DeviceFilterStrict]
    }
    
    extension [Self <: DeviceFilterStrict](x: Self) {
      
      inline def setInterfaceClass(value: integer): Self = StObject.set(x, "interfaceClass", value.asInstanceOf[js.Any])
      
      inline def setInterfaceClassUndefined: Self = StObject.set(x, "interfaceClass", js.undefined)
      
      inline def setInterfaceProtocol(value: integer): Self = StObject.set(x, "interfaceProtocol", value.asInstanceOf[js.Any])
      
      inline def setInterfaceProtocolUndefined: Self = StObject.set(x, "interfaceProtocol", js.undefined)
      
      inline def setInterfaceSubclass(value: integer): Self = StObject.set(x, "interfaceSubclass", value.asInstanceOf[js.Any])
      
      inline def setInterfaceSubclassUndefined: Self = StObject.set(x, "interfaceSubclass", js.undefined)
      
      inline def setProductId(value: integer): Self = StObject.set(x, "productId", value.asInstanceOf[js.Any])
      
      inline def setProductIdUndefined: Self = StObject.set(x, "productId", js.undefined)
      
      inline def setVendorId(value: integer): Self = StObject.set(x, "vendorId", value.asInstanceOf[js.Any])
    }
  }
  
  /** Since Chrome 29. */
  trait EndpointDescriptor extends StObject {
    
    /** Transfer type. */
    var address: integer
    
    /**
      * Transfer direction.
      * @see Direction
      */
    var direction: ToStringLiteral[
        IN, 
        /* keyof chrome-apps.anon.IN */ typingsJapgolly.chromeApps.chromeAppsStrings.IN | OUT, 
        /* import warning: importer.ImportType#apply Failed type conversion: keyof {  IN :'in',   OUT :'out'} extends keyof {  IN :'in',   OUT :'out'} ? std.Exclude<keyof {  IN :'in',   OUT :'out'}, 'in' | 'out'> : never */ js.Any
      ]
    
    /**
      * Extra descriptor data associated with this endpoint.
      * @since Chrome 39.
      */
    var extra_data: js.typedarray.ArrayBuffer
    
    /** Maximum packet size. */
    var maximumPacketSize: integer
    
    /** Polling interval (interrupt and isochronous only). */
    var pollingInterval: js.UndefOr[integer] = js.undefined
    
    /**
      * Transfer synchronization mode (isochronous only).
      * @see SynchronizationType
      */
    var synchronization: js.UndefOr[
        ToStringLiteral[
          ADAPTIVE, 
          /* keyof chrome-apps.anon.ADAPTIVE */ ASYNCHRONOUS | typingsJapgolly.chromeApps.chromeAppsStrings.ADAPTIVE | SYNCHRONOUS, 
          /* import warning: importer.ImportType#apply Failed type conversion: keyof {  ASYNCHRONOUS :'asynchronous',   ADAPTIVE :'adaptive',   SYNCHRONOUS :'synchronous'} extends keyof {  ASYNCHRONOUS :'asynchronous',   ADAPTIVE :'adaptive',   SYNCHRONOUS :'synchronous'} ? std.Exclude<keyof {  ASYNCHRONOUS :'asynchronous',   ADAPTIVE :'adaptive',   SYNCHRONOUS :'synchronous'}, 'asynchronous' | 'adaptive' | 'synchronous'> : never */ js.Any
        ]
      ] = js.undefined
    
    /**
      * Transfer type.
      * @see TransferType
      *
      */
    var `type`: ToStringLiteral[
        BULK, 
        /* keyof chrome-apps.anon.BULK */ CONTROL | INTERRUPT | ISOCHRONOUS | typingsJapgolly.chromeApps.chromeAppsStrings.BULK, 
        /* import warning: importer.ImportType#apply Failed type conversion: keyof {  CONTROL :'control',   INTERRUPT :'interrupt',   ISOCHRONOUS :'isochronous',   BULK :'bulk'} extends keyof {  CONTROL :'control',   INTERRUPT :'interrupt',   ISOCHRONOUS :'isochronous',   BULK :'bulk'} ? std.Exclude<keyof {  CONTROL :'control',   INTERRUPT :'interrupt',   ISOCHRONOUS :'isochronous',   BULK :'bulk'}, 'control' | 'interrupt' | 'isochronous' | 'bulk'> : never */ js.Any
      ]
    
    /**
      * Endpoint usage hint
      * @see UsageType
      */
    var usage: js.UndefOr[
        ToStringLiteral[
          DATA_, 
          /* keyof chrome-apps.anon.DATA */ DATA | FEEDBACK | EXPLICIT_FEEDBACK | PERIODIC | NOTIFICATION, 
          /* import warning: importer.ImportType#apply Failed type conversion: keyof {  DATA :'data',   FEEDBACK :'feedback',   EXPLICIT_FEEDBACK :'explicitFeedback',   PERIODIC :'periodic',   NOTIFICATION :'notification'} extends keyof {  DATA :'data',   FEEDBACK :'feedback',   EXPLICIT_FEEDBACK :'explicitFeedback',   PERIODIC :'periodic',   NOTIFICATION :'notification'} ? std.Exclude<keyof {  DATA :'data',   FEEDBACK :'feedback',   EXPLICIT_FEEDBACK :'explicitFeedback',   PERIODIC :'periodic',   NOTIFICATION :'notification'}, 'notification' | 'data' | 'periodic' | 'feedback' | 'explicitFeedback'> : never */ js.Any
        ]
      ] = js.undefined
  }
  object EndpointDescriptor {
    
    inline def apply(
      address: integer,
      direction: ToStringLiteral[
          IN, 
          /* keyof chrome-apps.anon.IN */ typingsJapgolly.chromeApps.chromeAppsStrings.IN | OUT, 
          /* import warning: importer.ImportType#apply Failed type conversion: keyof {  IN :'in',   OUT :'out'} extends keyof {  IN :'in',   OUT :'out'} ? std.Exclude<keyof {  IN :'in',   OUT :'out'}, 'in' | 'out'> : never */ js.Any
        ],
      extra_data: js.typedarray.ArrayBuffer,
      maximumPacketSize: integer,
      `type`: ToStringLiteral[
          BULK, 
          /* keyof chrome-apps.anon.BULK */ CONTROL | INTERRUPT | ISOCHRONOUS | typingsJapgolly.chromeApps.chromeAppsStrings.BULK, 
          /* import warning: importer.ImportType#apply Failed type conversion: keyof {  CONTROL :'control',   INTERRUPT :'interrupt',   ISOCHRONOUS :'isochronous',   BULK :'bulk'} extends keyof {  CONTROL :'control',   INTERRUPT :'interrupt',   ISOCHRONOUS :'isochronous',   BULK :'bulk'} ? std.Exclude<keyof {  CONTROL :'control',   INTERRUPT :'interrupt',   ISOCHRONOUS :'isochronous',   BULK :'bulk'}, 'control' | 'interrupt' | 'isochronous' | 'bulk'> : never */ js.Any
        ]
    ): EndpointDescriptor = {
      val __obj = js.Dynamic.literal(address = address.asInstanceOf[js.Any], direction = direction.asInstanceOf[js.Any], extra_data = extra_data.asInstanceOf[js.Any], maximumPacketSize = maximumPacketSize.asInstanceOf[js.Any])
      __obj.updateDynamic("type")(`type`.asInstanceOf[js.Any])
      __obj.asInstanceOf[EndpointDescriptor]
    }
    
    extension [Self <: EndpointDescriptor](x: Self) {
      
      inline def setAddress(value: integer): Self = StObject.set(x, "address", value.asInstanceOf[js.Any])
      
      inline def setDirection(
        value: ToStringLiteral[
              IN, 
              /* keyof chrome-apps.anon.IN */ typingsJapgolly.chromeApps.chromeAppsStrings.IN | OUT, 
              /* import warning: importer.ImportType#apply Failed type conversion: keyof {  IN :'in',   OUT :'out'} extends keyof {  IN :'in',   OUT :'out'} ? std.Exclude<keyof {  IN :'in',   OUT :'out'}, 'in' | 'out'> : never */ js.Any
            ]
      ): Self = StObject.set(x, "direction", value.asInstanceOf[js.Any])
      
      inline def setExtra_data(value: js.typedarray.ArrayBuffer): Self = StObject.set(x, "extra_data", value.asInstanceOf[js.Any])
      
      inline def setMaximumPacketSize(value: integer): Self = StObject.set(x, "maximumPacketSize", value.asInstanceOf[js.Any])
      
      inline def setPollingInterval(value: integer): Self = StObject.set(x, "pollingInterval", value.asInstanceOf[js.Any])
      
      inline def setPollingIntervalUndefined: Self = StObject.set(x, "pollingInterval", js.undefined)
      
      inline def setSynchronization(
        value: ToStringLiteral[
              ADAPTIVE, 
              /* keyof chrome-apps.anon.ADAPTIVE */ ASYNCHRONOUS | typingsJapgolly.chromeApps.chromeAppsStrings.ADAPTIVE | SYNCHRONOUS, 
              /* import warning: importer.ImportType#apply Failed type conversion: keyof {  ASYNCHRONOUS :'asynchronous',   ADAPTIVE :'adaptive',   SYNCHRONOUS :'synchronous'} extends keyof {  ASYNCHRONOUS :'asynchronous',   ADAPTIVE :'adaptive',   SYNCHRONOUS :'synchronous'} ? std.Exclude<keyof {  ASYNCHRONOUS :'asynchronous',   ADAPTIVE :'adaptive',   SYNCHRONOUS :'synchronous'}, 'asynchronous' | 'adaptive' | 'synchronous'> : never */ js.Any
            ]
      ): Self = StObject.set(x, "synchronization", value.asInstanceOf[js.Any])
      
      inline def setSynchronizationUndefined: Self = StObject.set(x, "synchronization", js.undefined)
      
      inline def setType(
        value: ToStringLiteral[
              BULK, 
              /* keyof chrome-apps.anon.BULK */ CONTROL | INTERRUPT | ISOCHRONOUS | typingsJapgolly.chromeApps.chromeAppsStrings.BULK, 
              /* import warning: importer.ImportType#apply Failed type conversion: keyof {  CONTROL :'control',   INTERRUPT :'interrupt',   ISOCHRONOUS :'isochronous',   BULK :'bulk'} extends keyof {  CONTROL :'control',   INTERRUPT :'interrupt',   ISOCHRONOUS :'isochronous',   BULK :'bulk'} ? std.Exclude<keyof {  CONTROL :'control',   INTERRUPT :'interrupt',   ISOCHRONOUS :'isochronous',   BULK :'bulk'}, 'control' | 'interrupt' | 'isochronous' | 'bulk'> : never */ js.Any
            ]
      ): Self = StObject.set(x, "type", value.asInstanceOf[js.Any])
      
      inline def setUsage(
        value: ToStringLiteral[
              DATA_, 
              /* keyof chrome-apps.anon.DATA */ DATA | FEEDBACK | EXPLICIT_FEEDBACK | PERIODIC | NOTIFICATION, 
              /* import warning: importer.ImportType#apply Failed type conversion: keyof {  DATA :'data',   FEEDBACK :'feedback',   EXPLICIT_FEEDBACK :'explicitFeedback',   PERIODIC :'periodic',   NOTIFICATION :'notification'} extends keyof {  DATA :'data',   FEEDBACK :'feedback',   EXPLICIT_FEEDBACK :'explicitFeedback',   PERIODIC :'periodic',   NOTIFICATION :'notification'} ? std.Exclude<keyof {  DATA :'data',   FEEDBACK :'feedback',   EXPLICIT_FEEDBACK :'explicitFeedback',   PERIODIC :'periodic',   NOTIFICATION :'notification'}, 'notification' | 'data' | 'periodic' | 'feedback' | 'explicitFeedback'> : never */ js.Any
            ]
      ): Self = StObject.set(x, "usage", value.asInstanceOf[js.Any])
      
      inline def setUsageUndefined: Self = StObject.set(x, "usage", js.undefined)
    }
  }
  
  trait GenericTransferInfo extends StObject {
    
    /** The data to transmit (required only by output transfers). */
    var data: js.UndefOr[js.typedarray.ArrayBuffer] = js.undefined
    
    /**
      * The transfer direction ('in' or 'out').
      * @see Direction
      */
    var direction: ToStringLiteral[
        IN, 
        /* keyof chrome-apps.anon.IN */ typingsJapgolly.chromeApps.chromeAppsStrings.IN | OUT, 
        /* import warning: importer.ImportType#apply Failed type conversion: keyof {  IN :'in',   OUT :'out'} extends keyof {  IN :'in',   OUT :'out'} ? std.Exclude<keyof {  IN :'in',   OUT :'out'}, 'in' | 'out'> : never */ js.Any
      ]
    
    /** The target endpoint address. The interface containing this endpoint must be claimed. */
    var endpoint: integer
    
    /** The maximum number of bytes to receive (required only by input transfers). */
    var length: js.UndefOr[integer] = js.undefined
    
    /**
      * Request timeout (in milliseconds).
      * The default value 0 indicates no timeout.
      * @default 0
      */
    var timeout: js.UndefOr[integer] = js.undefined
  }
  object GenericTransferInfo {
    
    inline def apply(
      direction: ToStringLiteral[
          IN, 
          /* keyof chrome-apps.anon.IN */ typingsJapgolly.chromeApps.chromeAppsStrings.IN | OUT, 
          /* import warning: importer.ImportType#apply Failed type conversion: keyof {  IN :'in',   OUT :'out'} extends keyof {  IN :'in',   OUT :'out'} ? std.Exclude<keyof {  IN :'in',   OUT :'out'}, 'in' | 'out'> : never */ js.Any
        ],
      endpoint: integer
    ): GenericTransferInfo = {
      val __obj = js.Dynamic.literal(direction = direction.asInstanceOf[js.Any], endpoint = endpoint.asInstanceOf[js.Any])
      __obj.asInstanceOf[GenericTransferInfo]
    }
    
    extension [Self <: GenericTransferInfo](x: Self) {
      
      inline def setData(value: js.typedarray.ArrayBuffer): Self = StObject.set(x, "data", value.asInstanceOf[js.Any])
      
      inline def setDataUndefined: Self = StObject.set(x, "data", js.undefined)
      
      inline def setDirection(
        value: ToStringLiteral[
              IN, 
              /* keyof chrome-apps.anon.IN */ typingsJapgolly.chromeApps.chromeAppsStrings.IN | OUT, 
              /* import warning: importer.ImportType#apply Failed type conversion: keyof {  IN :'in',   OUT :'out'} extends keyof {  IN :'in',   OUT :'out'} ? std.Exclude<keyof {  IN :'in',   OUT :'out'}, 'in' | 'out'> : never */ js.Any
            ]
      ): Self = StObject.set(x, "direction", value.asInstanceOf[js.Any])
      
      inline def setEndpoint(value: integer): Self = StObject.set(x, "endpoint", value.asInstanceOf[js.Any])
      
      inline def setLength(value: integer): Self = StObject.set(x, "length", value.asInstanceOf[js.Any])
      
      inline def setLengthUndefined: Self = StObject.set(x, "length", js.undefined)
      
      inline def setTimeout(value: integer): Self = StObject.set(x, "timeout", value.asInstanceOf[js.Any])
      
      inline def setTimeoutUndefined: Self = StObject.set(x, "timeout", js.undefined)
    }
  }
  
  /** @since Chrome 29. */
  trait InterfaceDescriptor extends StObject {
    
    /**
      * The interface alternate setting number.
      * @default 0
      */
    var alternateSetting: integer
    
    /** Description of the interface */
    var description: js.UndefOr[String] = js.undefined
    
    /** Available endpoints. */
    var endpoints: js.Array[EndpointDescriptor]
    
    /**
      * Extra descriptor data associated with this interface.
      * @since Chrome 39.
      */
    var extra_data: js.typedarray.ArrayBuffer
    
    /** The USB interface class. */
    var interfaceClass: integer
    
    /** The interface number */
    var interfaceNumber: integer
    
    /** The USB interface protocol. */
    var interfaceProtocol: integer
    
    /** The USB interface sub-class. */
    var interfaceSubclass: integer
  }
  object InterfaceDescriptor {
    
    inline def apply(
      alternateSetting: integer,
      endpoints: js.Array[EndpointDescriptor],
      extra_data: js.typedarray.ArrayBuffer,
      interfaceClass: integer,
      interfaceNumber: integer,
      interfaceProtocol: integer,
      interfaceSubclass: integer
    ): InterfaceDescriptor = {
      val __obj = js.Dynamic.literal(alternateSetting = alternateSetting.asInstanceOf[js.Any], endpoints = endpoints.asInstanceOf[js.Any], extra_data = extra_data.asInstanceOf[js.Any], interfaceClass = interfaceClass.asInstanceOf[js.Any], interfaceNumber = interfaceNumber.asInstanceOf[js.Any], interfaceProtocol = interfaceProtocol.asInstanceOf[js.Any], interfaceSubclass = interfaceSubclass.asInstanceOf[js.Any])
      __obj.asInstanceOf[InterfaceDescriptor]
    }
    
    extension [Self <: InterfaceDescriptor](x: Self) {
      
      inline def setAlternateSetting(value: integer): Self = StObject.set(x, "alternateSetting", value.asInstanceOf[js.Any])
      
      inline def setDescription(value: String): Self = StObject.set(x, "description", value.asInstanceOf[js.Any])
      
      inline def setDescriptionUndefined: Self = StObject.set(x, "description", js.undefined)
      
      inline def setEndpoints(value: js.Array[EndpointDescriptor]): Self = StObject.set(x, "endpoints", value.asInstanceOf[js.Any])
      
      inline def setEndpointsVarargs(value: EndpointDescriptor*): Self = StObject.set(x, "endpoints", js.Array(value*))
      
      inline def setExtra_data(value: js.typedarray.ArrayBuffer): Self = StObject.set(x, "extra_data", value.asInstanceOf[js.Any])
      
      inline def setInterfaceClass(value: integer): Self = StObject.set(x, "interfaceClass", value.asInstanceOf[js.Any])
      
      inline def setInterfaceNumber(value: integer): Self = StObject.set(x, "interfaceNumber", value.asInstanceOf[js.Any])
      
      inline def setInterfaceProtocol(value: integer): Self = StObject.set(x, "interfaceProtocol", value.asInstanceOf[js.Any])
      
      inline def setInterfaceSubclass(value: integer): Self = StObject.set(x, "interfaceSubclass", value.asInstanceOf[js.Any])
    }
  }
  
  trait IsochronousTransferInfo extends StObject {
    
    /** The length of each of the packets in this transfer. */
    var packetLength: integer
    
    /** The total number of packets in this transfer. */
    var packets: integer
    
    /**
      * Transfer parameters.
      * The transfer length or data buffer specified in this parameter block is split
      * along packetLength boundaries to form the individual packets of the transfer.
      */
    var transferInfo: GenericTransferInfo
  }
  object IsochronousTransferInfo {
    
    inline def apply(packetLength: integer, packets: integer, transferInfo: GenericTransferInfo): IsochronousTransferInfo = {
      val __obj = js.Dynamic.literal(packetLength = packetLength.asInstanceOf[js.Any], packets = packets.asInstanceOf[js.Any], transferInfo = transferInfo.asInstanceOf[js.Any])
      __obj.asInstanceOf[IsochronousTransferInfo]
    }
    
    extension [Self <: IsochronousTransferInfo](x: Self) {
      
      inline def setPacketLength(value: integer): Self = StObject.set(x, "packetLength", value.asInstanceOf[js.Any])
      
      inline def setPackets(value: integer): Self = StObject.set(x, "packets", value.asInstanceOf[js.Any])
      
      inline def setTransferInfo(value: GenericTransferInfo): Self = StObject.set(x, "transferInfo", value.asInstanceOf[js.Any])
    }
  }
  
  trait TransferInfo extends StObject {
    
    /** The data to transmit (required only by output transfers). */
    var data: js.UndefOr[js.typedarray.ArrayBuffer] = js.undefined
    
    /**
      * The transfer direction ('in' or 'out').
      * @see Direction
      */
    var direction: ToStringLiteral[
        IN, 
        /* keyof chrome-apps.anon.IN */ typingsJapgolly.chromeApps.chromeAppsStrings.IN | OUT, 
        /* import warning: importer.ImportType#apply Failed type conversion: keyof {  IN :'in',   OUT :'out'} extends keyof {  IN :'in',   OUT :'out'} ? std.Exclude<keyof {  IN :'in',   OUT :'out'}, 'in' | 'out'> : never */ js.Any
      ]
    
    /** The wIndex field, see *Ibid*. */
    var index: integer
    
    /** The maximum number of bytes to receive(required only by input transfers). */
    var length: js.UndefOr[integer] = js.undefined
    
    /**
      * The transfer target.
      * The target given by index must be claimed if 'interface' or 'endpoint'.
      * @see Recipient
      */
    var recipient: ToStringLiteral[
        DEVICE, 
        /* keyof chrome-apps.anon.DEVICE */ typingsJapgolly.chromeApps.chromeAppsStrings.DEVICE | INTERFACE | ENDPOINT | OTHER, 
        /* import warning: importer.ImportType#apply Failed type conversion: keyof {  DEVICE :'device',   INTERFACE :'interface',   ENDPOINT :'endpoint',   OTHER :'other'} extends keyof {  DEVICE :'device',   INTERFACE :'interface',   ENDPOINT :'endpoint',   OTHER :'other'} ? std.Exclude<keyof {  DEVICE :'device',   INTERFACE :'interface',   ENDPOINT :'endpoint',   OTHER :'other'}, 'device' | 'interface' | 'endpoint' | 'other'> : never */ js.Any
      ]
    
    /** The bRequest field, see *Universal Serial Bus Specification Revision 1.1 § 9.3.* */
    var request: integer
    
    /**
      * The request type.
      * @see RequestType
      */
    var requestType: ToStringLiteral[
        CLASS, 
        /* keyof chrome-apps.anon.CLASS */ STANDARD | typingsJapgolly.chromeApps.chromeAppsStrings.CLASS | VENDOR | RESERVED, 
        /* import warning: importer.ImportType#apply Failed type conversion: keyof {  STANDARD :'standard',   CLASS :'class',   VENDOR :'vendor',   RESERVED :'reserved'} extends keyof {  STANDARD :'standard',   CLASS :'class',   VENDOR :'vendor',   RESERVED :'reserved'} ? std.Exclude<keyof {  STANDARD :'standard',   CLASS :'class',   VENDOR :'vendor',   RESERVED :'reserved'}, 'standard' | 'class' | 'vendor' | 'reserved'> : never */ js.Any
      ]
    
    /**
      * @since Chrome 43.
      * Request timeout (in milliseconds).
      * The default value 0 indicates no timeout.
      * @default 0
      */
    var timeout: js.UndefOr[integer] = js.undefined
    
    /** The wValue field, see *Ibid*. */
    var value: integer
  }
  object TransferInfo {
    
    inline def apply(
      direction: ToStringLiteral[
          IN, 
          /* keyof chrome-apps.anon.IN */ typingsJapgolly.chromeApps.chromeAppsStrings.IN | OUT, 
          /* import warning: importer.ImportType#apply Failed type conversion: keyof {  IN :'in',   OUT :'out'} extends keyof {  IN :'in',   OUT :'out'} ? std.Exclude<keyof {  IN :'in',   OUT :'out'}, 'in' | 'out'> : never */ js.Any
        ],
      index: integer,
      recipient: ToStringLiteral[
          DEVICE, 
          /* keyof chrome-apps.anon.DEVICE */ typingsJapgolly.chromeApps.chromeAppsStrings.DEVICE | INTERFACE | ENDPOINT | OTHER, 
          /* import warning: importer.ImportType#apply Failed type conversion: keyof {  DEVICE :'device',   INTERFACE :'interface',   ENDPOINT :'endpoint',   OTHER :'other'} extends keyof {  DEVICE :'device',   INTERFACE :'interface',   ENDPOINT :'endpoint',   OTHER :'other'} ? std.Exclude<keyof {  DEVICE :'device',   INTERFACE :'interface',   ENDPOINT :'endpoint',   OTHER :'other'}, 'device' | 'interface' | 'endpoint' | 'other'> : never */ js.Any
        ],
      request: integer,
      requestType: ToStringLiteral[
          CLASS, 
          /* keyof chrome-apps.anon.CLASS */ STANDARD | typingsJapgolly.chromeApps.chromeAppsStrings.CLASS | VENDOR | RESERVED, 
          /* import warning: importer.ImportType#apply Failed type conversion: keyof {  STANDARD :'standard',   CLASS :'class',   VENDOR :'vendor',   RESERVED :'reserved'} extends keyof {  STANDARD :'standard',   CLASS :'class',   VENDOR :'vendor',   RESERVED :'reserved'} ? std.Exclude<keyof {  STANDARD :'standard',   CLASS :'class',   VENDOR :'vendor',   RESERVED :'reserved'}, 'standard' | 'class' | 'vendor' | 'reserved'> : never */ js.Any
        ],
      value: integer
    ): TransferInfo = {
      val __obj = js.Dynamic.literal(direction = direction.asInstanceOf[js.Any], index = index.asInstanceOf[js.Any], recipient = recipient.asInstanceOf[js.Any], request = request.asInstanceOf[js.Any], requestType = requestType.asInstanceOf[js.Any], value = value.asInstanceOf[js.Any])
      __obj.asInstanceOf[TransferInfo]
    }
    
    extension [Self <: TransferInfo](x: Self) {
      
      inline def setData(value: js.typedarray.ArrayBuffer): Self = StObject.set(x, "data", value.asInstanceOf[js.Any])
      
      inline def setDataUndefined: Self = StObject.set(x, "data", js.undefined)
      
      inline def setDirection(
        value: ToStringLiteral[
              IN, 
              /* keyof chrome-apps.anon.IN */ typingsJapgolly.chromeApps.chromeAppsStrings.IN | OUT, 
              /* import warning: importer.ImportType#apply Failed type conversion: keyof {  IN :'in',   OUT :'out'} extends keyof {  IN :'in',   OUT :'out'} ? std.Exclude<keyof {  IN :'in',   OUT :'out'}, 'in' | 'out'> : never */ js.Any
            ]
      ): Self = StObject.set(x, "direction", value.asInstanceOf[js.Any])
      
      inline def setIndex(value: integer): Self = StObject.set(x, "index", value.asInstanceOf[js.Any])
      
      inline def setLength(value: integer): Self = StObject.set(x, "length", value.asInstanceOf[js.Any])
      
      inline def setLengthUndefined: Self = StObject.set(x, "length", js.undefined)
      
      inline def setRecipient(
        value: ToStringLiteral[
              DEVICE, 
              /* keyof chrome-apps.anon.DEVICE */ typingsJapgolly.chromeApps.chromeAppsStrings.DEVICE | INTERFACE | ENDPOINT | OTHER, 
              /* import warning: importer.ImportType#apply Failed type conversion: keyof {  DEVICE :'device',   INTERFACE :'interface',   ENDPOINT :'endpoint',   OTHER :'other'} extends keyof {  DEVICE :'device',   INTERFACE :'interface',   ENDPOINT :'endpoint',   OTHER :'other'} ? std.Exclude<keyof {  DEVICE :'device',   INTERFACE :'interface',   ENDPOINT :'endpoint',   OTHER :'other'}, 'device' | 'interface' | 'endpoint' | 'other'> : never */ js.Any
            ]
      ): Self = StObject.set(x, "recipient", value.asInstanceOf[js.Any])
      
      inline def setRequest(value: integer): Self = StObject.set(x, "request", value.asInstanceOf[js.Any])
      
      inline def setRequestType(
        value: ToStringLiteral[
              CLASS, 
              /* keyof chrome-apps.anon.CLASS */ STANDARD | typingsJapgolly.chromeApps.chromeAppsStrings.CLASS | VENDOR | RESERVED, 
              /* import warning: importer.ImportType#apply Failed type conversion: keyof {  STANDARD :'standard',   CLASS :'class',   VENDOR :'vendor',   RESERVED :'reserved'} extends keyof {  STANDARD :'standard',   CLASS :'class',   VENDOR :'vendor',   RESERVED :'reserved'} ? std.Exclude<keyof {  STANDARD :'standard',   CLASS :'class',   VENDOR :'vendor',   RESERVED :'reserved'}, 'standard' | 'class' | 'vendor' | 'reserved'> : never */ js.Any
            ]
      ): Self = StObject.set(x, "requestType", value.asInstanceOf[js.Any])
      
      inline def setTimeout(value: integer): Self = StObject.set(x, "timeout", value.asInstanceOf[js.Any])
      
      inline def setTimeoutUndefined: Self = StObject.set(x, "timeout", js.undefined)
      
      inline def setValue(value: integer): Self = StObject.set(x, "value", value.asInstanceOf[js.Any])
    }
  }
  
  trait TransferResultInfo extends StObject {
    
    /** The data returned by an input transfer. undefined for output transfers. */
    var data: js.UndefOr[js.typedarray.ArrayBuffer] = js.undefined
    
    /** A value of 0 indicates that the transfer was a success. Other values indicate failure. */
    var resultCode: js.UndefOr[integer] = js.undefined
  }
  object TransferResultInfo {
    
    inline def apply(): TransferResultInfo = {
      val __obj = js.Dynamic.literal()
      __obj.asInstanceOf[TransferResultInfo]
    }
    
    extension [Self <: TransferResultInfo](x: Self) {
      
      inline def setData(value: js.typedarray.ArrayBuffer): Self = StObject.set(x, "data", value.asInstanceOf[js.Any])
      
      inline def setDataUndefined: Self = StObject.set(x, "data", js.undefined)
      
      inline def setResultCode(value: integer): Self = StObject.set(x, "resultCode", value.asInstanceOf[js.Any])
      
      inline def setResultCodeUndefined: Self = StObject.set(x, "resultCode", js.undefined)
    }
  }
}
