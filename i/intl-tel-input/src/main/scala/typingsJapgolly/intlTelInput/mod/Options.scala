package typingsJapgolly.intlTelInput.mod

import japgolly.scalajs.react.Callback
import japgolly.scalajs.react.CallbackTo
import org.scalajs.dom.raw.Node
import typingsJapgolly.intlTelInput.intlTelInputStrings.aggressive
import typingsJapgolly.intlTelInput.intlTelInputStrings.off
import typingsJapgolly.intlTelInput.intlTelInputStrings.polite
import typingsJapgolly.intlTelInput.mod.intlTelInputUtils.CountryData
import typingsJapgolly.intlTelInput.mod.intlTelInputUtils.placeholderNumberType
import scala.scalajs.js
import scala.scalajs.js.`|`
import scala.scalajs.js.annotation._

trait Options extends js.Object {
  /**
    * Whether or not to allow the dropdown. If disabled, there is no dropdown
    * arrow, and the selected flag is not clickable. Also we display the
    * selected flag on the right instead because it is just a marker of state.
    * Default = true
    */
  var allowDropdown: js.UndefOr[Boolean] = js.undefined
  /**
    * If there is just a dial code in the input: remove it on blur or submit,
    * and re-add it on focus. This is to prevent just a dial code getting
    * submitted with the form. Requires nationalMode to be set to false.
    * Default = true
    */
  var autoHideDialCode: js.UndefOr[Boolean] = js.undefined
  /**
    * Set the input's placeholder to an example number for the selected country, and update it if the country changes.
    * You can specify the number type using the placeholderNumberType option.
    * By default it is set to "polite", which means it will only set the placeholder if the input doesn't already have one.
    * You can also set it to "aggressive", which will replace any existing placeholder, or "off".
    * Requires the utilsScript option.
    * Default = "polite"
    */
  var autoPlaceholder: js.UndefOr[off | polite | aggressive] = js.undefined
  /**
    * Change the placeholder generated by autoPlaceholder. Must return a string.
    * Default = null
    */
  var customPlaceholder: js.UndefOr[
    js.Function2[
      /* selectedCountryPlaceholder */ String, 
      /* selectedCountryData */ CountryData, 
      String
    ]
  ] = js.undefined
  /**
    * Expects a node e.g. document.body. Instead of putting the country dropdown next to the input,
    * append it to the specified node, and it will then be positioned absolutely next to the input using JavaScript.
    * This is useful when the input is inside a container with overflow: hidden.
    * Note that the absolute positioning can be broken by scrolling, so it will automatically close on the window scroll event.
    * Default = null
    */
  var dropdownContainer: js.UndefOr[Node] = js.undefined
  /**
    * In the dropdown, display all countries except the ones you specify here.
    * Default = null
    */
  var excludeCountries: js.UndefOr[js.Array[String]] = js.undefined
  /**
    * Format the input value (according to the nationalMode option) during initialisation, and on setNumber.
    * Requires the utilsScript option.
    * Default = true
    */
  var formatOnDisplay: js.UndefOr[Boolean] = js.undefined
  /**
    * When setting initialCountry to "auto", you must use this option to
    * specify a custom function that looks up the user's location,
    * and then calls the success callback with the relevant country code.
    * Also note that when instantiating the plugin, if the Promise object is defined,
    * one of those is returned under the promise instance property, so you can
    * do something like iti.promise.then(callback) to know when initialisation requests like this have completed.
    * Default = null
    */
  var geoIpLookup: js.UndefOr[js.Function1[/* callback */ js.Function1[/* countryCode */ String, Unit], Unit]] = js.undefined
  /**
    * Add a hidden input with the given name (or if your input name contains square brackets then it will give the hidden input the same name,
    * replacing the contents of the brackets with the given name). On submit, populate it with the full international number (using getNumber).
    * This is a quick way for people using non-ajax forms to get the full international number, even when nationalMode is enabled.
    * Note: requires the input to be inside a form element, as this feature works by listening for the submit event on the closest form element.
    * Also note that since this uses getNumber internally, it expects a valid number, and so should only be used after validation.
    * Default = ""
    */
  var hiddenInput: js.UndefOr[String] = js.undefined
  /**
    * Set the initial country selection by specifying it's country code.
    * You can also set it to "auto", which will lookup the user's country based
    * on their IP address (requires the geoIpLookup option).
    * Note that the "auto" option will not update the country selection if the
    * input already contains a number. If you leave initialCountry blank,
    * it will default to the first country in the list.
    */
  var initialCountry: js.UndefOr[String] = js.undefined
  /**
    * Allows to translate the countries by its given iso code e.g.: { 'de': 'Deutschland' }
    * Default = {}
    */
  var localizedCountries: js.UndefOr[js.Object] = js.undefined
  /**
    * Allow users to enter national numbers (and not have to think about
    * international dial codes). Formatting, validation and placeholders still
    * work. Then you can use getNumber to extract a full international number.
    * This option now defaults to true, and it is recommended that you leave it
    * that way as it provides a better experience for the user.
    * Default = true
    */
  var nationalMode: js.UndefOr[Boolean] = js.undefined
  /**
    * In the dropdown, display only the countries you specify.
    * Default = undefined
    */
  var onlyCountries: js.UndefOr[js.Array[String]] = js.undefined
  /**
    * Specify one of the keys from the global enum intlTelInputUtils.numberType
    * e.g. "FIXED_LINE" to set the number type to use for the placeholder.
    * Default = MOBILE
    */
  var placeholderNumberType: js.UndefOr[typingsJapgolly.intlTelInput.mod.intlTelInputUtils.placeholderNumberType] = js.undefined
  /**
    * Specify the countries to appear at the top of the list.
    * Default = ["us", "gb"]
    */
  var preferredCountries: js.UndefOr[js.Array[String]] = js.undefined
  /**
    * Display the country dial code next to the selected flag so it's not part
    * of the typed number. Note that this will disable nationalMode because
    * technically we are dealing with international numbers, but with the
    * dial code separated.
    * Default = false
    */
  var separateDialCode: js.UndefOr[Boolean] = js.undefined
  /**
    * Enable formatting/validation etc. by specifying the URL of the included utils.js script
    * (or alternatively just point it to the file on cdnjs.com). The script is fetched when the page has finished loading (on the window load event)
    *  to prevent blocking (the script is ~215KB). When instantiating the plugin, if the Promise object is defined,
    * one of those is returned under the promise instance property, so you can do something like
    * iti.promise.then(callback) to know when initialisation requests like this have finished.
    * Note that if you're lazy loading the plugin script itself (intlTelInput.js)
    * this will not work and you will need to use the loadUtils method instead.
    * Example: "build/js/utils.js"
    * Default = ""
    */
  var utilsScript: js.UndefOr[String] = js.undefined
}

object Options {
  @scala.inline
  def apply(
    allowDropdown: js.UndefOr[Boolean] = js.undefined,
    autoHideDialCode: js.UndefOr[Boolean] = js.undefined,
    autoPlaceholder: off | polite | aggressive = null,
    customPlaceholder: (/* selectedCountryPlaceholder */ String, /* selectedCountryData */ CountryData) => CallbackTo[String] = null,
    dropdownContainer: Node = null,
    excludeCountries: js.Array[String] = null,
    formatOnDisplay: js.UndefOr[Boolean] = js.undefined,
    geoIpLookup: /* callback */ js.Function1[/* countryCode */ String, Unit] => Callback = null,
    hiddenInput: String = null,
    initialCountry: String = null,
    localizedCountries: js.Object = null,
    nationalMode: js.UndefOr[Boolean] = js.undefined,
    onlyCountries: js.Array[String] = null,
    placeholderNumberType: placeholderNumberType = null,
    preferredCountries: js.Array[String] = null,
    separateDialCode: js.UndefOr[Boolean] = js.undefined,
    utilsScript: String = null
  ): Options = {
    val __obj = js.Dynamic.literal()
    if (!js.isUndefined(allowDropdown)) __obj.updateDynamic("allowDropdown")(allowDropdown.asInstanceOf[js.Any])
    if (!js.isUndefined(autoHideDialCode)) __obj.updateDynamic("autoHideDialCode")(autoHideDialCode.asInstanceOf[js.Any])
    if (autoPlaceholder != null) __obj.updateDynamic("autoPlaceholder")(autoPlaceholder.asInstanceOf[js.Any])
    if (customPlaceholder != null) __obj.updateDynamic("customPlaceholder")(js.Any.fromFunction2((t0: /* selectedCountryPlaceholder */ java.lang.String, t1: /* selectedCountryData */ typingsJapgolly.intlTelInput.mod.intlTelInputUtils.CountryData) => customPlaceholder(t0, t1).runNow()))
    if (dropdownContainer != null) __obj.updateDynamic("dropdownContainer")(dropdownContainer.asInstanceOf[js.Any])
    if (excludeCountries != null) __obj.updateDynamic("excludeCountries")(excludeCountries.asInstanceOf[js.Any])
    if (!js.isUndefined(formatOnDisplay)) __obj.updateDynamic("formatOnDisplay")(formatOnDisplay.asInstanceOf[js.Any])
    if (geoIpLookup != null) __obj.updateDynamic("geoIpLookup")(js.Any.fromFunction1((t0: /* callback */ js.Function1[/* countryCode */ java.lang.String, scala.Unit]) => geoIpLookup(t0).runNow()))
    if (hiddenInput != null) __obj.updateDynamic("hiddenInput")(hiddenInput.asInstanceOf[js.Any])
    if (initialCountry != null) __obj.updateDynamic("initialCountry")(initialCountry.asInstanceOf[js.Any])
    if (localizedCountries != null) __obj.updateDynamic("localizedCountries")(localizedCountries.asInstanceOf[js.Any])
    if (!js.isUndefined(nationalMode)) __obj.updateDynamic("nationalMode")(nationalMode.asInstanceOf[js.Any])
    if (onlyCountries != null) __obj.updateDynamic("onlyCountries")(onlyCountries.asInstanceOf[js.Any])
    if (placeholderNumberType != null) __obj.updateDynamic("placeholderNumberType")(placeholderNumberType.asInstanceOf[js.Any])
    if (preferredCountries != null) __obj.updateDynamic("preferredCountries")(preferredCountries.asInstanceOf[js.Any])
    if (!js.isUndefined(separateDialCode)) __obj.updateDynamic("separateDialCode")(separateDialCode.asInstanceOf[js.Any])
    if (utilsScript != null) __obj.updateDynamic("utilsScript")(utilsScript.asInstanceOf[js.Any])
    __obj.asInstanceOf[Options]
  }
}

