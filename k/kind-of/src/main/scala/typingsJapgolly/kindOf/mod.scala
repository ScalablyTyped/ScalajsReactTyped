package typingsJapgolly.kindOf

import typingsJapgolly.kindOf.kindOfStrings.`null`
import typingsJapgolly.kindOf.kindOfStrings.arguments
import typingsJapgolly.kindOf.kindOfStrings.array
import typingsJapgolly.kindOf.kindOfStrings.arrayiterator
import typingsJapgolly.kindOf.kindOfStrings.boolean
import typingsJapgolly.kindOf.kindOfStrings.buffer
import typingsJapgolly.kindOf.kindOfStrings.date
import typingsJapgolly.kindOf.kindOfStrings.error
import typingsJapgolly.kindOf.kindOfStrings.float32array
import typingsJapgolly.kindOf.kindOfStrings.float64array
import typingsJapgolly.kindOf.kindOfStrings.function
import typingsJapgolly.kindOf.kindOfStrings.generator
import typingsJapgolly.kindOf.kindOfStrings.generatorfunction
import typingsJapgolly.kindOf.kindOfStrings.int16array
import typingsJapgolly.kindOf.kindOfStrings.int32array
import typingsJapgolly.kindOf.kindOfStrings.int8array
import typingsJapgolly.kindOf.kindOfStrings.map
import typingsJapgolly.kindOf.kindOfStrings.mapiterator
import typingsJapgolly.kindOf.kindOfStrings.number
import typingsJapgolly.kindOf.kindOfStrings.promise
import typingsJapgolly.kindOf.kindOfStrings.regexp
import typingsJapgolly.kindOf.kindOfStrings.set
import typingsJapgolly.kindOf.kindOfStrings.setiterator
import typingsJapgolly.kindOf.kindOfStrings.string
import typingsJapgolly.kindOf.kindOfStrings.stringiterator
import typingsJapgolly.kindOf.kindOfStrings.symbol
import typingsJapgolly.kindOf.kindOfStrings.uint16array
import typingsJapgolly.kindOf.kindOfStrings.uint32array
import typingsJapgolly.kindOf.kindOfStrings.uint8array
import typingsJapgolly.kindOf.kindOfStrings.uint8clampedarray
import typingsJapgolly.kindOf.kindOfStrings.undefined
import typingsJapgolly.kindOf.kindOfStrings.weakmap
import typingsJapgolly.kindOf.kindOfStrings.weakset
import typingsJapgolly.node.bufferMod.global.Buffer
import typingsJapgolly.std.Map
import typingsJapgolly.std.Set
import typingsJapgolly.std.WeakMap
import typingsJapgolly.std.WeakSet
import org.scalablytyped.runtime.StObject
import scala.scalajs.js
import scala.scalajs.js.annotation.{JSGlobalScope, JSGlobal, JSImport, JSName, JSBracketAccess}

object mod {
  
  inline def apply(thing: String): string = ^.asInstanceOf[js.Dynamic].apply(thing.asInstanceOf[js.Any]).asInstanceOf[string]
  inline def apply(thing: js.Array[Any]): array = ^.asInstanceOf[js.Dynamic].apply(thing.asInstanceOf[js.Any]).asInstanceOf[array]
  inline def apply(thing: js.Date): date = ^.asInstanceOf[js.Dynamic].apply(thing.asInstanceOf[js.Any]).asInstanceOf[date]
  inline def apply(thing: js.Error): error = ^.asInstanceOf[js.Dynamic].apply(thing.asInstanceOf[js.Any]).asInstanceOf[error]
  inline def apply(thing: js.Function1[/* repeated */ Any, Any]): function | generatorfunction = ^.asInstanceOf[js.Dynamic].apply(thing.asInstanceOf[js.Any]).asInstanceOf[function | generatorfunction]
  inline def apply(thing: js.Iterator[Any]): generator | stringiterator | arrayiterator | mapiterator | setiterator = ^.asInstanceOf[js.Dynamic].apply(thing.asInstanceOf[js.Any]).asInstanceOf[generator | stringiterator | arrayiterator | mapiterator | setiterator]
  inline def apply(thing: js.Promise[Any]): promise = ^.asInstanceOf[js.Dynamic].apply(thing.asInstanceOf[js.Any]).asInstanceOf[promise]
  inline def apply(thing: js.RegExp): regexp = ^.asInstanceOf[js.Dynamic].apply(thing.asInstanceOf[js.Any]).asInstanceOf[regexp]
  inline def apply(thing: js.Symbol): symbol = ^.asInstanceOf[js.Dynamic].apply(thing.asInstanceOf[js.Any]).asInstanceOf[symbol]
  inline def apply(thing: js.typedarray.Float32Array): float32array = ^.asInstanceOf[js.Dynamic].apply(thing.asInstanceOf[js.Any]).asInstanceOf[float32array]
  inline def apply(thing: js.typedarray.Float64Array): float64array = ^.asInstanceOf[js.Dynamic].apply(thing.asInstanceOf[js.Any]).asInstanceOf[float64array]
  inline def apply(thing: js.typedarray.Int16Array): int16array = ^.asInstanceOf[js.Dynamic].apply(thing.asInstanceOf[js.Any]).asInstanceOf[int16array]
  inline def apply(thing: js.typedarray.Int32Array): int32array = ^.asInstanceOf[js.Dynamic].apply(thing.asInstanceOf[js.Any]).asInstanceOf[int32array]
  inline def apply(thing: js.typedarray.Int8Array): int8array = ^.asInstanceOf[js.Dynamic].apply(thing.asInstanceOf[js.Any]).asInstanceOf[int8array]
  inline def apply(thing: js.typedarray.Uint16Array): uint16array = ^.asInstanceOf[js.Dynamic].apply(thing.asInstanceOf[js.Any]).asInstanceOf[uint16array]
  inline def apply(thing: js.typedarray.Uint32Array): uint32array = ^.asInstanceOf[js.Dynamic].apply(thing.asInstanceOf[js.Any]).asInstanceOf[uint32array]
  inline def apply(thing: js.typedarray.Uint8Array): uint8array = ^.asInstanceOf[js.Dynamic].apply(thing.asInstanceOf[js.Any]).asInstanceOf[uint8array]
  inline def apply(thing: js.typedarray.Uint8ClampedArray): uint8clampedarray = ^.asInstanceOf[js.Dynamic].apply(thing.asInstanceOf[js.Any]).asInstanceOf[uint8clampedarray]
  inline def apply(thing: /* import warning: ResolveTypeQueries.resolve Couldn't resolve typeof arguments */ Any): arguments = ^.asInstanceOf[js.Dynamic].apply(thing.asInstanceOf[js.Any]).asInstanceOf[arguments]
  inline def apply(thing: Boolean): boolean = ^.asInstanceOf[js.Dynamic].apply(thing.asInstanceOf[js.Any]).asInstanceOf[boolean]
  inline def apply(thing: Double): number = ^.asInstanceOf[js.Dynamic].apply(thing.asInstanceOf[js.Any]).asInstanceOf[number]
  inline def apply(thing: Null): `null` = ^.asInstanceOf[js.Dynamic].apply(thing.asInstanceOf[js.Any]).asInstanceOf[`null`]
  inline def apply(thing: Unit): undefined = ^.asInstanceOf[js.Dynamic].apply(thing.asInstanceOf[js.Any]).asInstanceOf[undefined]
  inline def apply(thing: Buffer): buffer = ^.asInstanceOf[js.Dynamic].apply(thing.asInstanceOf[js.Any]).asInstanceOf[buffer]
  inline def apply(thing: Map[Any, Any]): map = ^.asInstanceOf[js.Dynamic].apply(thing.asInstanceOf[js.Any]).asInstanceOf[map]
  inline def apply(thing: Set[Any]): set = ^.asInstanceOf[js.Dynamic].apply(thing.asInstanceOf[js.Any]).asInstanceOf[set]
  inline def apply(thing: WeakMap[Any, Any]): weakmap = ^.asInstanceOf[js.Dynamic].apply(thing.asInstanceOf[js.Any]).asInstanceOf[weakmap]
  inline def apply(thing: WeakSet[Any]): weakset = ^.asInstanceOf[js.Dynamic].apply(thing.asInstanceOf[js.Any]).asInstanceOf[weakset]
  
  @JSImport("kind-of", JSImport.Namespace)
  @js.native
  val ^ : js.Any = js.native
}
