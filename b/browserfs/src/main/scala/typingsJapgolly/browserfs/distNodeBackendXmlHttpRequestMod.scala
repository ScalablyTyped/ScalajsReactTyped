package typingsJapgolly.browserfs

import org.scalablytyped.runtime.StringDictionary
import typingsJapgolly.browserfs.distNodeCoreFileFlagMod.FileFlag
import typingsJapgolly.browserfs.distNodeCoreFileMod.File
import typingsJapgolly.browserfs.distNodeCoreFileSystemMod.BFSCallback
import typingsJapgolly.browserfs.distNodeCoreFileSystemMod.BFSOneArgCallback
import typingsJapgolly.browserfs.distNodeCoreFileSystemMod.BaseFileSystem
import typingsJapgolly.browserfs.distNodeCoreFileSystemMod.FileSystem
import typingsJapgolly.browserfs.distNodeCoreFileSystemMod.FileSystemOptions
import typingsJapgolly.node.bufferMod.global.Buffer
import org.scalablytyped.runtime.StObject
import scala.scalajs.js
import scala.scalajs.js.annotation.{JSGlobalScope, JSGlobal, JSImport, JSName, JSBracketAccess}

object distNodeBackendXmlHttpRequestMod {
  
  @JSImport("browserfs/dist/node/backend/XmlHttpRequest", JSImport.Default)
  @js.native
  open class default protected () extends XmlHttpRequest {
    /**
      * **Deprecated. Please use XmlHttpRequest.Create() method instead to construct XmlHttpRequest objects.**
      *
      * Constructs the file system. You must provide the directory listing as a JSON object
      * produced by the `make_xhrfs_index` script.
      *
      * **DEPRECATED:** You may pass a URL to the file index to the constructor, which will fetch the file index
      * *synchronously* and may freeze up the web page. This behavior will be removed in the next major version
      * of BrowserFS.
      *
      * @param listingUrlOrObj index object or the path to the JSON file index generated by
      *   `make_xhrfs_index`.
      * @param prefixUrl URL that is prepended to any file locations in the file index. e.g. if `prefixUrl = 'data/`, and the user wants to open the file `/foo.txt`,
      * the file system will fetch file `data/foo.txt`. The browser will access the file relative to the currrent webpage
      * URL.
      */
    def this(listingUrlOrObj: String) = this()
    def this(listingUrlOrObj: js.Object) = this()
    def this(listingUrlOrObj: String, prefixUrl: String) = this()
    def this(listingUrlOrObj: js.Object, prefixUrl: String) = this()
    def this(listingUrlOrObj: String, prefixUrl: String, deprecateMsg: Boolean) = this()
    def this(listingUrlOrObj: String, prefixUrl: Unit, deprecateMsg: Boolean) = this()
    def this(listingUrlOrObj: js.Object, prefixUrl: String, deprecateMsg: Boolean) = this()
    def this(listingUrlOrObj: js.Object, prefixUrl: Unit, deprecateMsg: Boolean) = this()
  }
  /* static members */
  object default {
    
    @JSImport("browserfs/dist/node/backend/XmlHttpRequest", JSImport.Default)
    @js.native
    val ^ : js.Any = js.native
    
    /**
      * Construct an XmlHttpRequest file system backend with the given options.
      */
    inline def Create(opts: XmlHttpRequestOptions, cb: BFSCallback[XmlHttpRequest]): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("Create")(opts.asInstanceOf[js.Any], cb.asInstanceOf[js.Any])).asInstanceOf[Unit]
    
    /**
      * **Deprecated. Please use XmlHttpRequest.Create() method instead to construct XmlHttpRequest objects.**
      *
      * Constructs an XmlHttpRequest object using the directory listing at the given URL.
      * Uses the base URL as the URL prefix for fetched files.
      * @param cb Called when the file system has been instantiated, or if an error occurs.
      */
    inline def FromURL(url: String, cb: BFSCallback[XmlHttpRequest]): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("FromURL")(url.asInstanceOf[js.Any], cb.asInstanceOf[js.Any])).asInstanceOf[Unit]
    inline def FromURL(url: String, cb: BFSCallback[XmlHttpRequest], baseUrl: String): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("FromURL")(url.asInstanceOf[js.Any], cb.asInstanceOf[js.Any], baseUrl.asInstanceOf[js.Any])).asInstanceOf[Unit]
    inline def FromURL(url: String, cb: BFSCallback[XmlHttpRequest], baseUrl: String, deprecateMsg: Boolean): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("FromURL")(url.asInstanceOf[js.Any], cb.asInstanceOf[js.Any], baseUrl.asInstanceOf[js.Any], deprecateMsg.asInstanceOf[js.Any])).asInstanceOf[Unit]
    inline def FromURL(url: String, cb: BFSCallback[XmlHttpRequest], baseUrl: Unit, deprecateMsg: Boolean): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("FromURL")(url.asInstanceOf[js.Any], cb.asInstanceOf[js.Any], baseUrl.asInstanceOf[js.Any], deprecateMsg.asInstanceOf[js.Any])).asInstanceOf[Unit]
    
    @JSImport("browserfs/dist/node/backend/XmlHttpRequest", "default.Name")
    @js.native
    val Name: String = js.native
    
    @JSImport("browserfs/dist/node/backend/XmlHttpRequest", "default.Options")
    @js.native
    val Options: FileSystemOptions = js.native
    
    inline def isAvailable(): Boolean = ^.asInstanceOf[js.Dynamic].applyDynamic("isAvailable")().asInstanceOf[Boolean]
  }
  
  @js.native
  trait XmlHttpRequest
    extends BaseFileSystem
       with FileSystem {
    
    /* private */ var _index: Any = js.native
    
    /**
      * Asynchronously download the given file.
      */
    /* private */ def _requestFileAsync(p: Any, `type`: Any, cb: Any): Any = js.native
    
    /**
      * Only requests the HEAD content, for the file size.
      */
    /* private */ def _requestFileSizeAsync(path: Any, cb: Any): Any = js.native
    
    /* private */ def _requestFileSizeSync(path: Any): Any = js.native
    
    /**
      * Synchronously download the given file.
      */
    /* private */ def _requestFileSync(p: Any, `type`: Any): Any = js.native
    
    /* InferMemberOverrides */
    override def chmod(p: String, isLchmod: Boolean, mode: Double, cb: BFSOneArgCallback): Unit = js.native
    
    /* InferMemberOverrides */
    override def chmodSync(p: String, isLchmod: Boolean, mode: Double): Unit = js.native
    
    /* InferMemberOverrides */
    override def chown(p: String, isLchown: Boolean, uid: Double, gid: Double, cb: BFSOneArgCallback): Unit = js.native
    
    /* InferMemberOverrides */
    override def chownSync(p: String, isLchown: Boolean, uid: Double, gid: Double): Unit = js.native
    
    /* InferMemberOverrides */
    override def diskSpace(p: String, cb: js.Function2[/* total */ Double, /* free */ Double, Any]): Unit = js.native
    
    def empty(): Unit = js.native
    
    /* InferMemberOverrides */
    override def exists(p: String, cb: js.Function1[/* exists */ Boolean, Unit]): Unit = js.native
    
    /* InferMemberOverrides */
    override def existsSync(p: String): Boolean = js.native
    
    /* private */ def getXhrPath(filePath: Any): Any = js.native
    
    /* InferMemberOverrides */
    override def link(srcpath: String, dstpath: String, cb: BFSOneArgCallback): Unit = js.native
    
    /* InferMemberOverrides */
    override def linkSync(srcpath: String, dstpath: String): Unit = js.native
    
    /* InferMemberOverrides */
    override def mkdir(p: String, mode: Double, cb: BFSOneArgCallback): Unit = js.native
    
    /* InferMemberOverrides */
    override def mkdirSync(p: String, mode: Double): Unit = js.native
    
    /* InferMemberOverrides */
    override def open(p: String, flag: FileFlag, mode: Double, cb: BFSCallback[File]): Unit = js.native
    
    /* InferMemberOverrides */
    override def openSync(p: String, flag: FileFlag, mode: Double): File = js.native
    
    val prefixUrl: String = js.native
    
    /**
      * Special XHR function: Preload the given file into the index.
      * @param [String] path
      * @param [BrowserFS.Buffer] buffer
      */
    def preloadFile(path: String, buffer: Buffer): Unit = js.native
    
    /* InferMemberOverrides */
    override def readFile(fname: String, encoding: String, flag: FileFlag, cb: BFSCallback[String | Buffer]): Unit = js.native
    /* InferMemberOverrides */
    override def readFile(fname: String, encoding: Null, flag: FileFlag, cb: BFSCallback[String | Buffer]): Unit = js.native
    
    /* InferMemberOverrides */
    override def readFileSync(fname: String, encoding: String, flag: FileFlag): Any = js.native
    /* InferMemberOverrides */
    override def readFileSync(fname: String, encoding: Null, flag: FileFlag): Any = js.native
    
    /* InferMemberOverrides */
    override def readdir(p: String, cb: BFSCallback[js.Array[String]]): Unit = js.native
    
    /* InferMemberOverrides */
    override def readdirSync(p: String): js.Array[String] = js.native
    
    /* InferMemberOverrides */
    override def readlinkSync(p: String): String = js.native
    
    /* InferMemberOverrides */
    override def realpath(p: String, cache: StringDictionary[String], cb: BFSCallback[String]): Unit = js.native
    
    /* InferMemberOverrides */
    override def realpathSync(p: String, cache: StringDictionary[String]): String = js.native
    
    /* InferMemberOverrides */
    override def rename(oldPath: String, newPath: String, cb: BFSOneArgCallback): Unit = js.native
    
    /* InferMemberOverrides */
    override def renameSync(oldPath: String, newPath: String): Unit = js.native
    
    /* InferMemberOverrides */
    override def rmdir(p: String, cb: BFSOneArgCallback): Unit = js.native
    
    /* InferMemberOverrides */
    override def rmdirSync(p: String): Unit = js.native
    
    /* InferMemberOverrides */
    override def stat(
      p: String,
      isLstat: Boolean,
      cb: BFSCallback[typingsJapgolly.browserfs.distNodeCoreNodeFsStatsMod.default]
    ): Unit = js.native
    /* InferMemberOverrides */
    override def stat(
      p: String,
      isLstat: Null,
      cb: BFSCallback[typingsJapgolly.browserfs.distNodeCoreNodeFsStatsMod.default]
    ): Unit = js.native
    
    /* InferMemberOverrides */
    override def statSync(p: String): typingsJapgolly.browserfs.distNodeCoreNodeFsStatsMod.default = js.native
    /* InferMemberOverrides */
    override def statSync(p: String, isLstat: Boolean): typingsJapgolly.browserfs.distNodeCoreNodeFsStatsMod.default = js.native
    
    /* InferMemberOverrides */
    override def supportsLinks(): Boolean = js.native
    
    /* InferMemberOverrides */
    override def symlink(srcpath: String, dstpath: String, `type`: String, cb: BFSOneArgCallback): Unit = js.native
    
    /* InferMemberOverrides */
    override def symlinkSync(srcpath: String, dstpath: String, `type`: String): Unit = js.native
    
    /* InferMemberOverrides */
    override def truncate(p: String, len: Double, cb: BFSOneArgCallback): Unit = js.native
    
    /* InferMemberOverrides */
    override def truncateSync(p: String, len: Double): Unit = js.native
    
    /* InferMemberOverrides */
    override def unlink(p: String, cb: BFSOneArgCallback): Unit = js.native
    
    /* InferMemberOverrides */
    override def unlinkSync(p: String): Unit = js.native
    
    /* InferMemberOverrides */
    override def utimes(p: String, atime: js.Date, mtime: js.Date, cb: BFSOneArgCallback): Unit = js.native
    
    /* InferMemberOverrides */
    override def utimesSync(p: String, atime: js.Date, mtime: js.Date): Unit = js.native
    
    /* InferMemberOverrides */
    override def writeFile(fname: String, data: Any, encoding: String, flag: FileFlag, mode: Double, cb: BFSOneArgCallback): Unit = js.native
    /* InferMemberOverrides */
    override def writeFile(fname: String, data: Any, encoding: Null, flag: FileFlag, mode: Double, cb: BFSOneArgCallback): Unit = js.native
  }
  
  trait XmlHttpRequestOptions extends StObject {
    
    var baseUrl: js.UndefOr[String] = js.undefined
    
    var index: js.UndefOr[String | js.Object] = js.undefined
  }
  object XmlHttpRequestOptions {
    
    inline def apply(): XmlHttpRequestOptions = {
      val __obj = js.Dynamic.literal()
      __obj.asInstanceOf[XmlHttpRequestOptions]
    }
    
    extension [Self <: XmlHttpRequestOptions](x: Self) {
      
      inline def setBaseUrl(value: String): Self = StObject.set(x, "baseUrl", value.asInstanceOf[js.Any])
      
      inline def setBaseUrlUndefined: Self = StObject.set(x, "baseUrl", js.undefined)
      
      inline def setIndex(value: String | js.Object): Self = StObject.set(x, "index", value.asInstanceOf[js.Any])
      
      inline def setIndexUndefined: Self = StObject.set(x, "index", js.undefined)
    }
  }
}
