package typingsJapgolly.binaryParser

import org.scalablytyped.runtime.Instantiable0
import org.scalablytyped.runtime.NumberDictionary
import org.scalablytyped.runtime.Shortcut
import typingsJapgolly.binaryParser.mod.Parser.ArrayOptions
import typingsJapgolly.binaryParser.mod.Parser.BufferOptions
import typingsJapgolly.binaryParser.mod.Parser.ChoiceOptions
import typingsJapgolly.binaryParser.mod.Parser.Endianness
import typingsJapgolly.binaryParser.mod.Parser.NestOptions
import typingsJapgolly.binaryParser.mod.Parser.Next
import typingsJapgolly.binaryParser.mod.Parser.Options
import typingsJapgolly.binaryParser.mod.Parser.Parsed
import typingsJapgolly.binaryParser.mod.Parser.StringOptions
import typingsJapgolly.node.bufferMod.global.Buffer
import typingsJapgolly.std.ObjectConstructor
import org.scalablytyped.runtime.StObject
import scala.scalajs.js
import scala.scalajs.js.annotation.{JSGlobalScope, JSGlobal, JSImport, JSName, JSBracketAccess}

object mod {
  
  @js.native
  trait Parser[O /* <: js.UndefOr[js.Object] */] extends StObject {
    
    def array[N /* <: String */, Q /* <: ArrayOptions */](name: N, options: Q): Next[
        O, 
        N, 
        /* import warning: importer.ImportType#apply Failed type conversion: Q extends {  type :infer T} ? T extends binary-parser.binary-parser.Parser<infer O> ? O extends undefined ? std.Array<{}> : std.Array<O> : T extends string ? std.Array<number> : never : never */ js.Any
      ] = js.native
    
    def bit1[N /* <: String */](name: N): Next[O, N, Double] = js.native
    def bit1[N /* <: String */](name: N, options: Options): Next[O, N, Double] = js.native
    
    def bit10[N /* <: String */](name: N): Next[O, N, Double] = js.native
    def bit10[N /* <: String */](name: N, options: Options): Next[O, N, Double] = js.native
    
    def bit11[N /* <: String */](name: N): Next[O, N, Double] = js.native
    def bit11[N /* <: String */](name: N, options: Options): Next[O, N, Double] = js.native
    
    def bit12[N /* <: String */](name: N): Next[O, N, Double] = js.native
    def bit12[N /* <: String */](name: N, options: Options): Next[O, N, Double] = js.native
    
    def bit13[N /* <: String */](name: N): Next[O, N, Double] = js.native
    def bit13[N /* <: String */](name: N, options: Options): Next[O, N, Double] = js.native
    
    def bit14[N /* <: String */](name: N): Next[O, N, Double] = js.native
    def bit14[N /* <: String */](name: N, options: Options): Next[O, N, Double] = js.native
    
    def bit15[N /* <: String */](name: N): Next[O, N, Double] = js.native
    def bit15[N /* <: String */](name: N, options: Options): Next[O, N, Double] = js.native
    
    def bit16[N /* <: String */](name: N): Next[O, N, Double] = js.native
    def bit16[N /* <: String */](name: N, options: Options): Next[O, N, Double] = js.native
    
    def bit17[N /* <: String */](name: N): Next[O, N, Double] = js.native
    def bit17[N /* <: String */](name: N, options: Options): Next[O, N, Double] = js.native
    
    def bit18[N /* <: String */](name: N): Next[O, N, Double] = js.native
    def bit18[N /* <: String */](name: N, options: Options): Next[O, N, Double] = js.native
    
    def bit19[N /* <: String */](name: N): Next[O, N, Double] = js.native
    def bit19[N /* <: String */](name: N, options: Options): Next[O, N, Double] = js.native
    
    def bit2[N /* <: String */](name: N): Next[O, N, Double] = js.native
    def bit2[N /* <: String */](name: N, options: Options): Next[O, N, Double] = js.native
    
    def bit20[N /* <: String */](name: N): Next[O, N, Double] = js.native
    def bit20[N /* <: String */](name: N, options: Options): Next[O, N, Double] = js.native
    
    def bit21[N /* <: String */](name: N): Next[O, N, Double] = js.native
    def bit21[N /* <: String */](name: N, options: Options): Next[O, N, Double] = js.native
    
    def bit22[N /* <: String */](name: N): Next[O, N, Double] = js.native
    def bit22[N /* <: String */](name: N, options: Options): Next[O, N, Double] = js.native
    
    def bit23[N /* <: String */](name: N): Next[O, N, Double] = js.native
    def bit23[N /* <: String */](name: N, options: Options): Next[O, N, Double] = js.native
    
    def bit24[N /* <: String */](name: N): Next[O, N, Double] = js.native
    def bit24[N /* <: String */](name: N, options: Options): Next[O, N, Double] = js.native
    
    def bit25[N /* <: String */](name: N): Next[O, N, Double] = js.native
    def bit25[N /* <: String */](name: N, options: Options): Next[O, N, Double] = js.native
    
    def bit26[N /* <: String */](name: N): Next[O, N, Double] = js.native
    def bit26[N /* <: String */](name: N, options: Options): Next[O, N, Double] = js.native
    
    def bit27[N /* <: String */](name: N): Next[O, N, Double] = js.native
    def bit27[N /* <: String */](name: N, options: Options): Next[O, N, Double] = js.native
    
    def bit28[N /* <: String */](name: N): Next[O, N, Double] = js.native
    def bit28[N /* <: String */](name: N, options: Options): Next[O, N, Double] = js.native
    
    def bit29[N /* <: String */](name: N): Next[O, N, Double] = js.native
    def bit29[N /* <: String */](name: N, options: Options): Next[O, N, Double] = js.native
    
    def bit3[N /* <: String */](name: N): Next[O, N, Double] = js.native
    def bit3[N /* <: String */](name: N, options: Options): Next[O, N, Double] = js.native
    
    def bit30[N /* <: String */](name: N): Next[O, N, Double] = js.native
    def bit30[N /* <: String */](name: N, options: Options): Next[O, N, Double] = js.native
    
    def bit31[N /* <: String */](name: N): Next[O, N, Double] = js.native
    def bit31[N /* <: String */](name: N, options: Options): Next[O, N, Double] = js.native
    
    def bit32[N /* <: String */](name: N): Next[O, N, Double] = js.native
    def bit32[N /* <: String */](name: N, options: Options): Next[O, N, Double] = js.native
    
    def bit4[N /* <: String */](name: N): Next[O, N, Double] = js.native
    def bit4[N /* <: String */](name: N, options: Options): Next[O, N, Double] = js.native
    
    def bit5[N /* <: String */](name: N): Next[O, N, Double] = js.native
    def bit5[N /* <: String */](name: N, options: Options): Next[O, N, Double] = js.native
    
    def bit6[N /* <: String */](name: N): Next[O, N, Double] = js.native
    def bit6[N /* <: String */](name: N, options: Options): Next[O, N, Double] = js.native
    
    def bit7[N /* <: String */](name: N): Next[O, N, Double] = js.native
    def bit7[N /* <: String */](name: N, options: Options): Next[O, N, Double] = js.native
    
    def bit8[N /* <: String */](name: N): Next[O, N, Double] = js.native
    def bit8[N /* <: String */](name: N, options: Options): Next[O, N, Double] = js.native
    
    def bit9[N /* <: String */](name: N): Next[O, N, Double] = js.native
    def bit9[N /* <: String */](name: N, options: Options): Next[O, N, Double] = js.native
    
    def buffer[N /* <: String */](name: N, options: BufferOptions): Next[O, N, Buffer] = js.native
    
    def choice[N /* <: String */, Q /* <: ChoiceOptions */](name: N, options: Q): Next[
        O, 
        N, 
        /* import warning: importer.ImportType#apply Failed type conversion: Q extends {  choices :infer C} ? C extends {[ key in keyof C ]: infer T} ? T extends binary-parser.binary-parser.Parser<infer O> ? O extends undefined ? {} : O : T extends string ? any : never : never : never */ js.Any
      ] = js.native
    
    def compile(): Unit = js.native
    
    def create(constructorFunction: ObjectConstructor): Parser[Unit] = js.native
    
    def double[N /* <: String */](name: N): Next[O, N, Double] = js.native
    def double[N /* <: String */](name: N, options: Options): Next[O, N, Double] = js.native
    
    def doublebe[N /* <: String */](name: N): Next[O, N, Double] = js.native
    def doublebe[N /* <: String */](name: N, options: Options): Next[O, N, Double] = js.native
    
    def doublele[N /* <: String */](name: N): Next[O, N, Double] = js.native
    def doublele[N /* <: String */](name: N, options: Options): Next[O, N, Double] = js.native
    
    def endianess(endianess: Endianness): Parser[O] = js.native
    
    def float[N /* <: String */](name: N): Next[O, N, Double] = js.native
    def float[N /* <: String */](name: N, options: Options): Next[O, N, Double] = js.native
    
    def floatbe[N /* <: String */](name: N): Next[O, N, Double] = js.native
    def floatbe[N /* <: String */](name: N, options: Options): Next[O, N, Double] = js.native
    
    def floatle[N /* <: String */](name: N): Next[O, N, Double] = js.native
    def floatle[N /* <: String */](name: N, options: Options): Next[O, N, Double] = js.native
    
    def getCode(): String = js.native
    
    def int16[N /* <: String */](name: N): Next[O, N, Double] = js.native
    def int16[N /* <: String */](name: N, options: Options): Next[O, N, Double] = js.native
    
    def int16be[N /* <: String */](name: N): Next[O, N, Double] = js.native
    def int16be[N /* <: String */](name: N, options: Options): Next[O, N, Double] = js.native
    
    def int16le[N /* <: String */](name: N): Next[O, N, Double] = js.native
    def int16le[N /* <: String */](name: N, options: Options): Next[O, N, Double] = js.native
    
    def int32[N /* <: String */](name: N): Next[O, N, Double] = js.native
    def int32[N /* <: String */](name: N, options: Options): Next[O, N, Double] = js.native
    
    def int32be[N /* <: String */](name: N): Next[O, N, Double] = js.native
    def int32be[N /* <: String */](name: N, options: Options): Next[O, N, Double] = js.native
    
    def int32le[N /* <: String */](name: N): Next[O, N, Double] = js.native
    def int32le[N /* <: String */](name: N, options: Options): Next[O, N, Double] = js.native
    
    def int64[N /* <: String */](name: N): Next[O, N, js.BigInt] = js.native
    def int64[N /* <: String */](name: N, options: Options): Next[O, N, js.BigInt] = js.native
    
    def int64be[N /* <: String */](name: N): Next[O, N, js.BigInt] = js.native
    def int64be[N /* <: String */](name: N, options: Options): Next[O, N, js.BigInt] = js.native
    
    def int64le[N /* <: String */](name: N): Next[O, N, js.BigInt] = js.native
    def int64le[N /* <: String */](name: N, options: Options): Next[O, N, js.BigInt] = js.native
    
    def int8[N /* <: String */](name: N): Next[O, N, Double] = js.native
    def int8[N /* <: String */](name: N, options: Options): Next[O, N, Double] = js.native
    
    /* [sic] */
    def namely(alias: String): Parser[O] = js.native
    
    def nest[N /* <: String */, Q /* <: NestOptions */](name: N, options: Q): Next[
        O, 
        N, 
        /* import warning: importer.ImportType#apply Failed type conversion: Q extends {  type :infer T} ? T extends binary-parser.binary-parser.Parser<infer O> ? O extends undefined ? {} : O : never : never */ js.Any
      ] = js.native
    
    def parse(buffer: Buffer): Parsed[O] = js.native
    def parse(
      buffer: Buffer,
      callback: js.Function2[/* err */ js.UndefOr[js.Error], /* result */ js.UndefOr[Any], Unit]
    ): Parsed[O] = js.native
    
    def seek(length: Double): Parser[O] = js.native
    
    def skip(length: Double): Parser[O] = js.native
    
    def string[N /* <: String */](name: N): Next[O, N, String] = js.native
    def string[N /* <: String */](name: N, options: StringOptions): Next[O, N, String] = js.native
    
    def uint16[N /* <: String */](name: N): Next[O, N, Double] = js.native
    def uint16[N /* <: String */](name: N, options: Options): Next[O, N, Double] = js.native
    
    def uint16be[N /* <: String */](name: N): Next[O, N, Double] = js.native
    def uint16be[N /* <: String */](name: N, options: Options): Next[O, N, Double] = js.native
    
    def uint16le[N /* <: String */](name: N): Next[O, N, Double] = js.native
    def uint16le[N /* <: String */](name: N, options: Options): Next[O, N, Double] = js.native
    
    def uint32[N /* <: String */](name: N): Next[O, N, Double] = js.native
    def uint32[N /* <: String */](name: N, options: Options): Next[O, N, Double] = js.native
    
    def uint32be[N /* <: String */](name: N): Next[O, N, Double] = js.native
    def uint32be[N /* <: String */](name: N, options: Options): Next[O, N, Double] = js.native
    
    def uint32le[N /* <: String */](name: N): Next[O, N, Double] = js.native
    def uint32le[N /* <: String */](name: N, options: Options): Next[O, N, Double] = js.native
    
    def uint64[N /* <: String */](name: N): Next[O, N, js.BigInt] = js.native
    def uint64[N /* <: String */](name: N, options: Options): Next[O, N, js.BigInt] = js.native
    
    def uint64be[N /* <: String */](name: N): Next[O, N, js.BigInt] = js.native
    def uint64be[N /* <: String */](name: N, options: Options): Next[O, N, js.BigInt] = js.native
    
    def uint64le[N /* <: String */](name: N): Next[O, N, js.BigInt] = js.native
    def uint64le[N /* <: String */](name: N, options: Options): Next[O, N, js.BigInt] = js.native
    
    def uint8[N /* <: String */](name: N): Next[O, N, Double] = js.native
    def uint8[N /* <: String */](name: N, options: Options): Next[O, N, Double] = js.native
  }
  object Parser extends Shortcut {
    
    /* This class was inferred from a value with a constructor. In rare cases (like HTMLElement in the DOM) it might not work as you expect. */
    @JSImport("binary-parser", "Parser")
    @js.native
    open class ^ ()
      extends StObject
         with Parser[Unit]
    
    @JSImport("binary-parser", "Parser")
    @js.native
    val ^ : ParserConstructor = js.native
    
    trait ArrayOptions
      extends StObject
         with Options {
      
      var length: js.UndefOr[Double | String | (js.ThisFunction0[/* this */ Parser[Any], Double])] = js.undefined
      
      var lengthInBytes: js.UndefOr[Double | String | (js.ThisFunction0[/* this */ Parser[Any], Double])] = js.undefined
      
      var readUntil: js.UndefOr[String | (js.Function2[/* item */ Double, /* buffer */ Buffer, Boolean])] = js.undefined
      
      var `type`: String | Parser[Any]
    }
    object ArrayOptions {
      
      inline def apply(`type`: String | Parser[Any]): ArrayOptions = {
        val __obj = js.Dynamic.literal()
        __obj.updateDynamic("type")(`type`.asInstanceOf[js.Any])
        __obj.asInstanceOf[ArrayOptions]
      }
      
      extension [Self <: ArrayOptions](x: Self) {
        
        inline def setLength(value: Double | String | (js.ThisFunction0[/* this */ Parser[Any], Double])): Self = StObject.set(x, "length", value.asInstanceOf[js.Any])
        
        inline def setLengthInBytes(value: Double | String | (js.ThisFunction0[/* this */ Parser[Any], Double])): Self = StObject.set(x, "lengthInBytes", value.asInstanceOf[js.Any])
        
        inline def setLengthInBytesUndefined: Self = StObject.set(x, "lengthInBytes", js.undefined)
        
        inline def setLengthUndefined: Self = StObject.set(x, "length", js.undefined)
        
        inline def setReadUntil(value: String | (js.Function2[/* item */ Double, /* buffer */ Buffer, Boolean])): Self = StObject.set(x, "readUntil", value.asInstanceOf[js.Any])
        
        inline def setReadUntilFunction2(value: (/* item */ Double, /* buffer */ Buffer) => Boolean): Self = StObject.set(x, "readUntil", js.Any.fromFunction2(value))
        
        inline def setReadUntilUndefined: Self = StObject.set(x, "readUntil", js.undefined)
        
        inline def setType(value: String | Parser[Any]): Self = StObject.set(x, "type", value.asInstanceOf[js.Any])
      }
    }
    
    trait BufferOptions
      extends StObject
         with Options {
      
      @JSName("clone")
      var clone_FBufferOptions: js.UndefOr[Boolean] = js.undefined
      
      var length: js.UndefOr[Double | String | (js.ThisFunction0[/* this */ Parser[Any], Double])] = js.undefined
      
      var readUntil: js.UndefOr[String | (js.Function2[/* item */ Double, /* buffer */ Buffer, Boolean])] = js.undefined
    }
    object BufferOptions {
      
      inline def apply(): BufferOptions = {
        val __obj = js.Dynamic.literal()
        __obj.asInstanceOf[BufferOptions]
      }
      
      extension [Self <: BufferOptions](x: Self) {
        
        inline def setClone_(value: Boolean): Self = StObject.set(x, "clone", value.asInstanceOf[js.Any])
        
        inline def setClone_Undefined: Self = StObject.set(x, "clone", js.undefined)
        
        inline def setLength(value: Double | String | (js.ThisFunction0[/* this */ Parser[Any], Double])): Self = StObject.set(x, "length", value.asInstanceOf[js.Any])
        
        inline def setLengthUndefined: Self = StObject.set(x, "length", js.undefined)
        
        inline def setReadUntil(value: String | (js.Function2[/* item */ Double, /* buffer */ Buffer, Boolean])): Self = StObject.set(x, "readUntil", value.asInstanceOf[js.Any])
        
        inline def setReadUntilFunction2(value: (/* item */ Double, /* buffer */ Buffer) => Boolean): Self = StObject.set(x, "readUntil", js.Any.fromFunction2(value))
        
        inline def setReadUntilUndefined: Self = StObject.set(x, "readUntil", js.undefined)
      }
    }
    
    trait ChoiceOptions
      extends StObject
         with Options {
      
      var choices: NumberDictionary[Parser[Any] | String]
      
      var defaultChoice: js.UndefOr[Parser[Any] | String] = js.undefined
      
      var tag: String | (js.ThisFunction0[/* this */ Parser[Any], Double])
    }
    object ChoiceOptions {
      
      inline def apply(
        choices: NumberDictionary[Parser[Any] | String],
        tag: String | (js.ThisFunction0[/* this */ Parser[Any], Double])
      ): ChoiceOptions = {
        val __obj = js.Dynamic.literal(choices = choices.asInstanceOf[js.Any], tag = tag.asInstanceOf[js.Any])
        __obj.asInstanceOf[ChoiceOptions]
      }
      
      extension [Self <: ChoiceOptions](x: Self) {
        
        inline def setChoices(value: NumberDictionary[Parser[Any] | String]): Self = StObject.set(x, "choices", value.asInstanceOf[js.Any])
        
        inline def setDefaultChoice(value: Parser[Any] | String): Self = StObject.set(x, "defaultChoice", value.asInstanceOf[js.Any])
        
        inline def setDefaultChoiceUndefined: Self = StObject.set(x, "defaultChoice", js.undefined)
        
        inline def setTag(value: String | (js.ThisFunction0[/* this */ Parser[Any], Double])): Self = StObject.set(x, "tag", value.asInstanceOf[js.Any])
      }
    }
    
    type Data = Double | String | (js.Array[Double | Parser[Any]]) | Parser[Any] | Buffer
    
    /* Rewritten from type alias, can be one of: 
      - typingsJapgolly.binaryParser.binaryParserStrings.little
      - typingsJapgolly.binaryParser.binaryParserStrings.big
    */
    trait Endianness extends StObject
    object Endianness {
      
      inline def big: typingsJapgolly.binaryParser.binaryParserStrings.big = "big".asInstanceOf[typingsJapgolly.binaryParser.binaryParserStrings.big]
      
      inline def little: typingsJapgolly.binaryParser.binaryParserStrings.little = "little".asInstanceOf[typingsJapgolly.binaryParser.binaryParserStrings.little]
    }
    
    trait NestOptions
      extends StObject
         with Options {
      
      var `type`: Parser[Any]
    }
    object NestOptions {
      
      inline def apply(`type`: Parser[Any]): NestOptions = {
        val __obj = js.Dynamic.literal()
        __obj.updateDynamic("type")(`type`.asInstanceOf[js.Any])
        __obj.asInstanceOf[NestOptions]
      }
      
      extension [Self <: NestOptions](x: Self) {
        
        inline def setType(value: Parser[Any]): Self = StObject.set(x, "type", value.asInstanceOf[js.Any])
      }
    }
    
    type Next[O /* <: js.UndefOr[js.Object] */, N /* <: String */, T /* <: Any */] = Parser[
        Valid[
          O, 
          /* import warning: importer.ImportType#apply Failed type conversion: {[ name in N ]: T} */ js.Any
        ]
      ]
    
    trait Options extends StObject {
      
      var assert: js.UndefOr[String | Double | (js.Function1[/* value */ Data, Boolean])] = js.undefined
      
      var formatter: js.UndefOr[js.Function1[/* value */ Data, Any]] = js.undefined
    }
    object Options {
      
      inline def apply(): Options = {
        val __obj = js.Dynamic.literal()
        __obj.asInstanceOf[Options]
      }
      
      extension [Self <: Options](x: Self) {
        
        inline def setAssert(value: String | Double | (js.Function1[/* value */ Data, Boolean])): Self = StObject.set(x, "assert", value.asInstanceOf[js.Any])
        
        inline def setAssertFunction1(value: /* value */ Data => Boolean): Self = StObject.set(x, "assert", js.Any.fromFunction1(value))
        
        inline def setAssertUndefined: Self = StObject.set(x, "assert", js.undefined)
        
        inline def setFormatter(value: /* value */ Data => Any): Self = StObject.set(x, "formatter", js.Any.fromFunction1(value))
        
        inline def setFormatterUndefined: Self = StObject.set(x, "formatter", js.undefined)
      }
    }
    
    /** NOTE: Conditional type definitions are impossible to translate to Scala.
      * See https://www.typescriptlang.org/docs/handbook/2/conditional-types.html for an intro.
      * You'll have to cast your way around this structure, unfortunately. 
      * TS definition: {{{
      O extends undefined ? {} : O
      }}}
      */
    @js.native
    trait Parsed[O /* <: js.UndefOr[js.Object] */] extends StObject
    
    trait StringOptions
      extends StObject
         with Options {
      
      var encoding: js.UndefOr[String] = js.undefined
      
      var greedy: js.UndefOr[Boolean] = js.undefined
      
      var length: js.UndefOr[Double | String | (js.ThisFunction0[/* this */ Parser[Any], Double])] = js.undefined
      
      var stripNull: js.UndefOr[Boolean] = js.undefined
      
      var zeroTerminated: js.UndefOr[Boolean] = js.undefined
    }
    object StringOptions {
      
      inline def apply(): StringOptions = {
        val __obj = js.Dynamic.literal()
        __obj.asInstanceOf[StringOptions]
      }
      
      extension [Self <: StringOptions](x: Self) {
        
        inline def setEncoding(value: String): Self = StObject.set(x, "encoding", value.asInstanceOf[js.Any])
        
        inline def setEncodingUndefined: Self = StObject.set(x, "encoding", js.undefined)
        
        inline def setGreedy(value: Boolean): Self = StObject.set(x, "greedy", value.asInstanceOf[js.Any])
        
        inline def setGreedyUndefined: Self = StObject.set(x, "greedy", js.undefined)
        
        inline def setLength(value: Double | String | (js.ThisFunction0[/* this */ Parser[Any], Double])): Self = StObject.set(x, "length", value.asInstanceOf[js.Any])
        
        inline def setLengthUndefined: Self = StObject.set(x, "length", js.undefined)
        
        inline def setStripNull(value: Boolean): Self = StObject.set(x, "stripNull", value.asInstanceOf[js.Any])
        
        inline def setStripNullUndefined: Self = StObject.set(x, "stripNull", js.undefined)
        
        inline def setZeroTerminated(value: Boolean): Self = StObject.set(x, "zeroTerminated", value.asInstanceOf[js.Any])
        
        inline def setZeroTerminatedUndefined: Self = StObject.set(x, "zeroTerminated", js.undefined)
      }
    }
    
    /** NOTE: Conditional type definitions are impossible to translate to Scala.
      * See https://www.typescriptlang.org/docs/handbook/2/conditional-types.html for an intro.
      * You'll have to cast your way around this structure, unfortunately. 
      * TS definition: {{{
      O extends undefined ? P : O & P
      }}}
      */
    @js.native
    trait Valid[O /* <: js.UndefOr[js.Object] */, P /* <: js.Object */] extends StObject
    
    type _To = ParserConstructor
    
    /* This means you don't have to write `^`, but can instead just say `Parser.foo` */
    override def _to: ParserConstructor = ^
  }
  
  @js.native
  trait ParserConstructor
    extends StObject
       with Instantiable0[Parser[Unit]]
}
