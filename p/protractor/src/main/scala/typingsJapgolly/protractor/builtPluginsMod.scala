package typingsJapgolly.protractor

import japgolly.scalajs.react.Callback
import japgolly.scalajs.react.CallbackTo
import org.scalablytyped.runtime.StringDictionary
import typingsJapgolly.protractor.anon.FailedCount
import typingsJapgolly.protractor.anon.SpecName
import typingsJapgolly.protractor.anon.`0`
import typingsJapgolly.protractor.builtBrowserMod.ProtractorBrowser
import typingsJapgolly.protractor.builtConfigMod.Config
import typingsJapgolly.q.mod.Promise
import org.scalablytyped.runtime.StObject
import scala.scalajs.js
import scala.scalajs.js.annotation.{JSGlobalScope, JSGlobal, JSImport, JSName, JSBracketAccess}

object builtPluginsMod {
  
  @JSImport("protractor/built/plugins", "Plugins")
  @js.native
  open class Plugins protected () extends StObject {
    def this(config: Config) = this()
    
    /**
      * Adds properties to a plugin's object
      *
      * @see docs/plugins.md#provided-properties-and-functions
      */
    /* private */ def annotatePluginObj(obj: Any, conf: Any, i: Any): Any = js.native
    
    var assertions: StringDictionary[js.Array[AssertionResult]] = js.native
    
    /**
      * Gets the tests results generated by any plugins
      *
      * @see lib/frameworks/README.md#requirements for a complete description of what
      *     the results object must look like
      *
      * @return {Object} The results object
      */
    def getResults(): FailedCount = js.native
    
    def onPageLoad(args: Any*): js.Promise[js.Array[Any]] = js.native
    
    def onPageStable(args: Any*): js.Promise[js.Array[Any]] = js.native
    
    def onPrepare(args: Any*): Promise[js.Array[Any]] = js.native
    
    /**
      * Generates the handler for a plugin function (e.g. the setup() function)
      *
      * @param {string} funName The name of the function to make a handler for
      * @param {PromiseType} promiseType The type of promise (WebDriver or Q) that should be used
      * @param {boolean=} failReturnVal The value that the function should return if the plugin crashes
      *
      * @return The handler
      */
    /* private */ def pluginFunFactory(funName: Any, promiseType: Any, failReturnVal: Any): Any = js.native
    
    var pluginObjs: js.Array[ProtractorPlugin] = js.native
    
    def postResults(args: Any*): Promise[js.Array[Any]] = js.native
    
    def postTest(args: Any*): Promise[js.Array[Any]] = js.native
    
    /* private */ def printPluginResults(specResults: Any): Any = js.native
    
    var resultsReported: Boolean = js.native
    
    /**
      * Calls a function from a plugin safely.  If the plugin's function throws an
      * exception or returns a rejected promise, that failure will be logged as a
      * failed test result instead of crashing protractor.  If the tests results have
      * already been reported, the failure will be logged to the console.
      *
      * @param {Object} pluginObj The plugin object containing the function to be run
      * @param {string} funName The name of the function we want to run
      * @param {*[]} args The arguments we want to invoke the function with
      * @param {PromiseType} promiseType The type of promise (WebDriver or Q) that
      *    should be used
      * @param {boolean} resultsReported If the results have already been reported
      * @param {*} failReturnVal The value to return if the function fails
      *
      * @return {webdriver.promise.Promise|Q.Promise} A promise which resolves to the
      *     function's return value
      */
    /* private */ def safeCallPluginFun(pluginObj: Any, funName: Any, args: Any, promiseType: Any, failReturnVal: Any): Any = js.native
    
    /**
      * @see docs/plugins.md#writing-plugins for information on these functions
      */
    def setup(args: Any*): Promise[js.Array[Any]] = js.native
    
    /**
      * Returns true if any loaded plugin has skipAngularStability enabled.
      *
      * @return {boolean}
      */
    def skipAngularStability(): Boolean = js.native
    
    def teardown(args: Any*): Promise[js.Array[Any]] = js.native
    
    def waitForCondition(args: Any*): js.Promise[js.Array[Any]] = js.native
    
    def waitForPromise(args: Any*): js.Promise[js.Array[Any]] = js.native
  }
  
  @js.native
  sealed trait PromiseType extends StObject
  @JSImport("protractor/built/plugins", "PromiseType")
  @js.native
  object PromiseType extends StObject {
    
    @JSBracketAccess
    def apply(value: Double): js.UndefOr[PromiseType & Double] = js.native
    
    @js.native
    sealed trait Q
      extends StObject
         with PromiseType
    /* 0 */ val Q: typingsJapgolly.protractor.builtPluginsMod.PromiseType.Q & Double = js.native
    
    @js.native
    sealed trait WEBDRIVER
      extends StObject
         with PromiseType
    /* 1 */ val WEBDRIVER: typingsJapgolly.protractor.builtPluginsMod.PromiseType.WEBDRIVER & Double = js.native
  }
  
  trait AssertionResult extends StObject {
    
    var errorMsg: js.UndefOr[String] = js.undefined
    
    var passed: Boolean
    
    var stackTrace: js.UndefOr[String] = js.undefined
  }
  object AssertionResult {
    
    inline def apply(passed: Boolean): AssertionResult = {
      val __obj = js.Dynamic.literal(passed = passed.asInstanceOf[js.Any])
      __obj.asInstanceOf[AssertionResult]
    }
    
    extension [Self <: AssertionResult](x: Self) {
      
      inline def setErrorMsg(value: String): Self = StObject.set(x, "errorMsg", value.asInstanceOf[js.Any])
      
      inline def setErrorMsgUndefined: Self = StObject.set(x, "errorMsg", js.undefined)
      
      inline def setPassed(value: Boolean): Self = StObject.set(x, "passed", value.asInstanceOf[js.Any])
      
      inline def setStackTrace(value: String): Self = StObject.set(x, "stackTrace", value.asInstanceOf[js.Any])
      
      inline def setStackTraceUndefined: Self = StObject.set(x, "stackTrace", js.undefined)
    }
  }
  
  trait PluginConfig
    extends StObject
       with /* key */ StringDictionary[Any] {
    
    @JSName("package")
    var _package: js.UndefOr[String] = js.undefined
    
    var `inline`: js.UndefOr[ProtractorPlugin] = js.undefined
    
    var name: js.UndefOr[String] = js.undefined
    
    var path: js.UndefOr[String] = js.undefined
  }
  object PluginConfig {
    
    inline def apply(): PluginConfig = {
      val __obj = js.Dynamic.literal()
      __obj.asInstanceOf[PluginConfig]
    }
    
    extension [Self <: PluginConfig](x: Self) {
      
      inline def setInline(value: ProtractorPlugin): Self = StObject.set(x, "inline", value.asInstanceOf[js.Any])
      
      inline def setInlineUndefined: Self = StObject.set(x, "inline", js.undefined)
      
      inline def setName(value: String): Self = StObject.set(x, "name", value.asInstanceOf[js.Any])
      
      inline def setNameUndefined: Self = StObject.set(x, "name", js.undefined)
      
      inline def setPath(value: String): Self = StObject.set(x, "path", value.asInstanceOf[js.Any])
      
      inline def setPathUndefined: Self = StObject.set(x, "path", js.undefined)
      
      inline def set_package(value: String): Self = StObject.set(x, "package", value.asInstanceOf[js.Any])
      
      inline def set_packageUndefined: Self = StObject.set(x, "package", js.undefined)
    }
  }
  
  trait ProtractorPlugin extends StObject {
    
    /**
      * Adds a failed assertion to the test's results.
      *
      * Note: this property is added by Protractor at runtime.  Any pre-existing
      * value will be overwritten.
      *
      * @param {string} message The error message for the failed assertion
      * @param {specName: string, stackTrace: string} options Some optional extra
      *     information about the assertion:
      *       - specName The name of the spec which this assertion belongs to.
      *            Defaults to `PLUGIN_NAME + ' Plugin Tests'`.
      *       - stackTrace The stack trace for the failure.  Defaults to undefined.
      *     Defaults to `{}`.
      *
      * @throws {Error} Throws an error if called after results have been reported
      */
    var addFailure: js.UndefOr[
        js.Function2[/* message */ js.UndefOr[String], /* info */ js.UndefOr[SpecName], Unit]
      ] = js.undefined
    
    /**
      * Adds a passed assertion to the test's results.
      *
      * Note: this property is added by Protractor at runtime.  Any pre-existing
      * value will be overwritten.
      *
      * @param {specName: string} options Extra information about the assertion:
      *       - specName The name of the spec which this assertion belongs to.
      *            Defaults to `PLUGIN_NAME + ' Plugin Tests'`.
      *     Defaults to `{}`.
      *
      * @throws {Error} Throws an error if called after results have been reported
      */
    var addSuccess: js.UndefOr[js.Function1[/* info */ js.UndefOr[`0`], Unit]] = js.undefined
    
    /**
      * Warns the user that something is problematic.
      *
      * Note: this property is added by Protractor at runtime.  Any pre-existing
      * value will be overwritten.
      *
      * @param {string} message The message to warn the user about
      * @param {specName: string} options Extra information about the assertion:
      *       - specName The name of the spec which this assertion belongs to.
      *            Defaults to `PLUGIN_NAME + ' Plugin Tests'`.
      *     Defaults to `{}`.
      */
    var addWarning: js.UndefOr[js.Function2[/* message */ js.UndefOr[String], /* info */ js.UndefOr[`0`], Unit]] = js.undefined
    
    /**
      * The plugin's configuration object.
      *
      * Note: this property is added by Protractor at runtime.  Any pre-existing
      * value will be overwritten.
      *
      * Note: that this is not the entire Protractor config object, just the entry
      * in the `plugins` array for this plugin.
      *
      * @type {Object}
      */
    var config: js.UndefOr[PluginConfig] = js.undefined
    
    /**
      * The name of the plugin.  Used when reporting results.
      *
      * If you do not specify this property, it will be filled in with something
      * reasonable (e.g. the plugin's path) by Protractor at runtime.
      *
      * @type {string}
      */
    var name: js.UndefOr[String] = js.undefined
    
    /**
      * This is called inside browser.get() directly after the page loads, and before
      * angular bootstraps.
      *
      * @param {ProtractorBrowser} browser The browser instance which is loading a page.
      *
      * @this {Object} bound to module.exports.
      *
      * @throws {*} If this function throws an error, a failed assertion is added to
      *     the test results.
      *
      * @return {webdriver.promise.Promise=} Can return a promise, in which case
      *     protractor will wait for the promise to resolve before continuing.  If
      *     the promise is rejected, a failed assertion is added to the test results.
      */
    var onPageLoad: js.UndefOr[js.Function1[/* browser */ ProtractorBrowser, Unit | js.Promise[Unit]]] = js.undefined
    
    /**
      * This is called inside browser.get() directly after angular is done
      * bootstrapping/synchronizing.  If `browser.ignoreSynchronization` is `true`,
      * this will not be called.
      *
      * @param {ProtractorBrowser} browser The browser instance which is loading a page.
      *
      * @this {Object} bound to module.exports.
      *
      * @throws {*} If this function throws an error, a failed assertion is added to
      *     the test results.
      *
      * @return {webdriver.promise.Promise=} Can return a promise, in which case
      *     protractor will wait for the promise to resolve before continuing.  If
      *     the promise is rejected, a failed assertion is added to the test results.
      */
    var onPageStable: js.UndefOr[js.Function1[/* browser */ ProtractorBrowser, Unit | js.Promise[Unit]]] = js.undefined
    
    /**
      * This is called before the test have been run but after the test framework has
      * been set up.  Analogous to a config file's `onPrepare`.
      *
      * Very similar to using `setup`, but allows you to access framework-specific
      * variables/functions (e.g. `jasmine.getEnv().addReporter()`).
      *
      * @this {Object} bound to module.exports.
      *
      * @throws {*} If this function throws an error, a failed assertion is added to
      *     the test results.
      *
      * @return {Promise=} Can return a promise, in which case protractor will wait
      *     for the promise to resolve before continuing.  If the promise is
      *     rejected, a failed assertion is added to the test results.
      */
    var onPrepare: js.UndefOr[js.Function0[Unit | js.Promise[Unit]]] = js.undefined
    
    /**
      * Called after the test results have been finalized and any jobs have been
      * updated (if applicable).
      *
      * @this {Object} bound to module.exports.
      *
      * @throws {*} If this function throws an error, it is outputted to the console.
      *     It is too late to add a failed assertion to the test results.
      *
      * @return {Promise=} Can return a promise, in which case protractor will wait
      *     for the promise to resolve before continuing.  If the promise is
      *     rejected, an error is logged to the console.
      */
    var postResults: js.UndefOr[js.Function0[Unit | js.Promise[Unit]]] = js.undefined
    
    /**
      * Called after each test block (in Jasmine, this means an `it` block)
      * completes.
      *
      * @param {boolean} passed True if the test passed.
      * @param {Object} testInfo information about the test which just ran.
      *
      * @this {Object} bound to module.exports.
      *
      * @throws {*} If this function throws an error, a failed assertion is added to
      *     the test results.
      *
      * @return {Promise=} Can return a promise, in which case protractor will wait
      *     for the promise to resolve before outputting test results.  Protractor
      *     will *not* wait before executing the next test; however, if the promise
      *     is rejected, a failed assertion is added to the test results.
      */
    var postTest: js.UndefOr[js.Function2[/* passed */ Boolean, /* testInfo */ Any, Unit | js.Promise[Unit]]] = js.undefined
    
    /**
      * Sets up plugins before tests are run. This is called after the WebDriver
      * session has been started, but before the test framework has been set up.
      *
      * @this {Object} bound to module.exports.
      *
      * @throws {*} If this function throws an error, a failed assertion is added to
      *     the test results.
      *
      * @return {Promise=} Can return a promise, in which case protractor will wait
      *     for the promise to resolve before continuing.  If the promise is
      *     rejected, a failed assertion is added to the test results.
      */
    var setup: js.UndefOr[js.Function0[Unit | js.Promise[Unit]]] = js.undefined
    
    /**
      * Used to turn off default checks for angular stability
      *
      * Normally Protractor waits for all $timeout and $http calls to be processed
      * before executing the next command.  This can be disabled using
      * browser.ignoreSynchronization, but that will also disable any
      * <Plugin>.waitForPromise or <Plugin>.waitForCondition checks.  If you want
      * to disable synchronization with angular, but leave intact any custom plugin
      * synchronization, this is the option for you.
      *
      * This is used by plugin authors who want to replace Protractor's
      * synchronization code with their own.
      *
      * @type {boolean}
      */
    var skipAngularStability: js.UndefOr[Boolean] = js.undefined
    
    /**
      * This is called after the tests have been run, but before the WebDriver
      * session has been terminated.
      *
      * @this {Object} bound to module.exports.
      *
      * @throws {*} If this function throws an error, a failed assertion is added to
      *     the test results.
      *
      * @return {Promise=} Can return a promise, in which case protractor will wait
      *     for the promise to resolve before continuing.  If the promise is
      *     rejected, a failed assertion is added to the test results.
      */
    var teardown: js.UndefOr[js.Function0[Unit | js.Promise[Unit]]] = js.undefined
    
    /**
      * Between every webdriver action, Protractor calls browser.waitForAngular() to
      * make sure that Angular has no outstanding $http or $timeout calls.
      * You can use waitForCondition() to have Protractor additionally wait for your
      * custom condition to be truthy.  If specified, this function will be called
      * repeatedly until truthy.
      *
      * @param {ProtractorBrowser} browser The browser instance which needs invoked `waitForAngular`.
      *
      * @this {Object} bound to module.exports.
      *
      * @throws {*} If this function throws an error, a failed assertion is added to
      *     the test results.
      *
      * @return {webdriver.promise.Promise<boolean>|boolean} If truthy, Protractor
      *     will continue onto the next command. If falsy, webdriver will
      *     continuously re-run this function until it is truthy.  If a rejected promise
      *     is returned, a failed assertion is added to the test results, and Protractor
      *     will continue onto the next command.
      */
    var waitForCondition: js.UndefOr[js.Function1[/* browser */ ProtractorBrowser, js.Promise[Boolean] | Boolean]] = js.undefined
    
    /**
      * Between every webdriver action, Protractor calls browser.waitForAngular() to
      * make sure that Angular has no outstanding $http or $timeout calls.
      * You can use waitForPromise() to have Protractor additionally wait for your
      * custom promise to be resolved inside of browser.waitForAngular().
      *
      * @param {ProtractorBrowser} browser The browser instance which needs invoked `waitForAngular`.
      *
      * @this {Object} bound to module.exports.
      *
      * @throws {*} If this function throws an error, a failed assertion is added to
      *     the test results.
      *
      * @return {webdriver.promise.Promise=} Can return a promise, in which case
      *     protractor will wait for the promise to resolve before continuing. If the
      *     promise is rejected, a failed assertion is added to the test results, and
      *     protractor will continue onto the next command. If nothing is returned or
      *     something other than a promise is returned, protractor will continue
      *     onto the next command.
      */
    var waitForPromise: js.UndefOr[js.Function1[/* browser */ ProtractorBrowser, js.Promise[Unit]]] = js.undefined
  }
  object ProtractorPlugin {
    
    inline def apply(): ProtractorPlugin = {
      val __obj = js.Dynamic.literal()
      __obj.asInstanceOf[ProtractorPlugin]
    }
    
    extension [Self <: ProtractorPlugin](x: Self) {
      
      inline def setAddFailure(value: (/* message */ js.UndefOr[String], /* info */ js.UndefOr[SpecName]) => Callback): Self = StObject.set(x, "addFailure", js.Any.fromFunction2((t0: /* message */ js.UndefOr[String], t1: /* info */ js.UndefOr[SpecName]) => (value(t0, t1)).runNow()))
      
      inline def setAddFailureUndefined: Self = StObject.set(x, "addFailure", js.undefined)
      
      inline def setAddSuccess(value: /* info */ js.UndefOr[`0`] => Callback): Self = StObject.set(x, "addSuccess", js.Any.fromFunction1((t0: /* info */ js.UndefOr[`0`]) => value(t0).runNow()))
      
      inline def setAddSuccessUndefined: Self = StObject.set(x, "addSuccess", js.undefined)
      
      inline def setAddWarning(value: (/* message */ js.UndefOr[String], /* info */ js.UndefOr[`0`]) => Callback): Self = StObject.set(x, "addWarning", js.Any.fromFunction2((t0: /* message */ js.UndefOr[String], t1: /* info */ js.UndefOr[`0`]) => (value(t0, t1)).runNow()))
      
      inline def setAddWarningUndefined: Self = StObject.set(x, "addWarning", js.undefined)
      
      inline def setConfig(value: PluginConfig): Self = StObject.set(x, "config", value.asInstanceOf[js.Any])
      
      inline def setConfigUndefined: Self = StObject.set(x, "config", js.undefined)
      
      inline def setName(value: String): Self = StObject.set(x, "name", value.asInstanceOf[js.Any])
      
      inline def setNameUndefined: Self = StObject.set(x, "name", js.undefined)
      
      inline def setOnPageLoad(value: /* browser */ ProtractorBrowser => Unit | js.Promise[Unit]): Self = StObject.set(x, "onPageLoad", js.Any.fromFunction1(value))
      
      inline def setOnPageLoadUndefined: Self = StObject.set(x, "onPageLoad", js.undefined)
      
      inline def setOnPageStable(value: /* browser */ ProtractorBrowser => Unit | js.Promise[Unit]): Self = StObject.set(x, "onPageStable", js.Any.fromFunction1(value))
      
      inline def setOnPageStableUndefined: Self = StObject.set(x, "onPageStable", js.undefined)
      
      inline def setOnPrepare(value: CallbackTo[Unit | js.Promise[Unit]]): Self = StObject.set(x, "onPrepare", value.toJsFn)
      
      inline def setOnPrepareUndefined: Self = StObject.set(x, "onPrepare", js.undefined)
      
      inline def setPostResults(value: CallbackTo[Unit | js.Promise[Unit]]): Self = StObject.set(x, "postResults", value.toJsFn)
      
      inline def setPostResultsUndefined: Self = StObject.set(x, "postResults", js.undefined)
      
      inline def setPostTest(value: (/* passed */ Boolean, /* testInfo */ Any) => Unit | js.Promise[Unit]): Self = StObject.set(x, "postTest", js.Any.fromFunction2(value))
      
      inline def setPostTestUndefined: Self = StObject.set(x, "postTest", js.undefined)
      
      inline def setSetup(value: CallbackTo[Unit | js.Promise[Unit]]): Self = StObject.set(x, "setup", value.toJsFn)
      
      inline def setSetupUndefined: Self = StObject.set(x, "setup", js.undefined)
      
      inline def setSkipAngularStability(value: Boolean): Self = StObject.set(x, "skipAngularStability", value.asInstanceOf[js.Any])
      
      inline def setSkipAngularStabilityUndefined: Self = StObject.set(x, "skipAngularStability", js.undefined)
      
      inline def setTeardown(value: CallbackTo[Unit | js.Promise[Unit]]): Self = StObject.set(x, "teardown", value.toJsFn)
      
      inline def setTeardownUndefined: Self = StObject.set(x, "teardown", js.undefined)
      
      inline def setWaitForCondition(value: /* browser */ ProtractorBrowser => js.Promise[Boolean] | Boolean): Self = StObject.set(x, "waitForCondition", js.Any.fromFunction1(value))
      
      inline def setWaitForConditionUndefined: Self = StObject.set(x, "waitForCondition", js.undefined)
      
      inline def setWaitForPromise(value: /* browser */ ProtractorBrowser => js.Promise[Unit]): Self = StObject.set(x, "waitForPromise", js.Any.fromFunction1(value))
      
      inline def setWaitForPromiseUndefined: Self = StObject.set(x, "waitForPromise", js.undefined)
    }
  }
  
  trait SpecResult extends StObject {
    
    var assertions: js.Array[AssertionResult]
    
    var description: String
  }
  object SpecResult {
    
    inline def apply(assertions: js.Array[AssertionResult], description: String): SpecResult = {
      val __obj = js.Dynamic.literal(assertions = assertions.asInstanceOf[js.Any], description = description.asInstanceOf[js.Any])
      __obj.asInstanceOf[SpecResult]
    }
    
    extension [Self <: SpecResult](x: Self) {
      
      inline def setAssertions(value: js.Array[AssertionResult]): Self = StObject.set(x, "assertions", value.asInstanceOf[js.Any])
      
      inline def setAssertionsVarargs(value: AssertionResult*): Self = StObject.set(x, "assertions", js.Array(value*))
      
      inline def setDescription(value: String): Self = StObject.set(x, "description", value.asInstanceOf[js.Any])
    }
  }
}
