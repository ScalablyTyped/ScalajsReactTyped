package typingsJapgolly.angularCompilerCli

import typingsJapgolly.angularCompilerCli.ngccSrcHostEsm2015HostMod.Esm2015ReflectionHost
import typingsJapgolly.angularCompilerCli.ngccSrcPackagesBundleProgramMod.BundleProgram
import typingsJapgolly.angularCompilerCli.srcNgtscLoggingSrcLoggerMod.Logger
import org.scalablytyped.runtime.StObject
import scala.scalajs.js
import scala.scalajs.js.annotation.{JSGlobalScope, JSGlobal, JSImport, JSName, JSBracketAccess}

object ngccSrcHostEsm5HostMod {
  
  @JSImport("@angular/compiler-cli/ngcc/src/host/esm5_host", "Esm5ReflectionHost")
  @js.native
  open class Esm5ReflectionHost protected () extends Esm2015ReflectionHost {
    def this(logger: Logger, isCore: Boolean, src: BundleProgram) = this()
    def this(logger: Logger, isCore: Boolean, src: BundleProgram, dts: BundleProgram) = this()
    
    /**
      * Inspects the provided expression and determines if it corresponds with a known helper function
      * as receiver expression.
      */
    /* private */ var extractKnownHelperCall: Any = js.native
    
    /**
      * Determines if the provided expression is one of the following call expressions:
      *
      * 1. `__spread(arguments)`
      * 2. `__spreadArray([], __read(arguments))`
      * 3. `__spreadArray([], __read(arguments), false)`
      *
      * The tslib helpers may have been emitted inline as in the above example, or they may be read
      * from a namespace import.
      */
    /* private */ var isSpreadArgumentsExpression: Any = js.native
    
    /**
      * Tests whether the expression corresponds to a `super` call passing through
      * function arguments without any modification. e.g.
      *
      * ```
      * _super !== null && _super.apply(this, arguments) || this;
      * ```
      *
      * This structure is generated by TypeScript when transforming ES2015 to ES5, see
      * https://github.com/Microsoft/TypeScript/blob/v3.2.2/src/compiler/transformers/es2015.ts#L1148-L1163
      *
      * Additionally, we also handle cases where `arguments` are wrapped by a TypeScript spread
      * helper.
      * This can happen if ES2015 class output contain auto-generated constructors due to class
      * members. The ES2015 output will be using `super(...arguments)` to delegate to the superclass,
      * but once downleveled to ES5, the spread operator will be persisted through a TypeScript spread
      * helper. For example:
      *
      * ```
      * _super.apply(this, __spread(arguments)) || this;
      * ```
      *
      * or, since TypeScript 4.2 it would be
      *
      * ```
      * _super.apply(this, tslib.__spreadArray([], tslib.__read(arguments))) || this;
      * ```
      *
      * More details can be found in: https://github.com/angular/angular/issues/38453.
      *
      * @param expression an expression that may represent a default super call
      * @returns true if the expression corresponds with the above form
      */
    /* private */ var isSuperApplyCall: Any = js.native
    
    /**
      * A constructor function may have been "synthesized" by TypeScript during JavaScript emit,
      * in the case no user-defined constructor exists and e.g. property initializers are used.
      * Those initializers need to be emitted into a constructor in JavaScript, so the TypeScript
      * compiler generates a synthetic constructor.
      *
      * We need to identify such constructors as ngcc needs to be able to tell if a class did
      * originally have a constructor in the TypeScript source. For ES5, we can not tell an
      * empty constructor apart from a synthesized constructor, but fortunately that does not
      * matter for the code generated by ngtsc.
      *
      * When a class has a superclass however, a synthesized constructor must not be considered
      * as a user-defined constructor as that prevents a base factory call from being created by
      * ngtsc, resulting in a factory function that does not inject the dependencies of the
      * superclass. Hence, we identify a default synthesized super call in the constructor body,
      * according to the structure that TypeScript's ES2015 to ES5 transformer generates in
      * https://github.com/Microsoft/TypeScript/blob/v3.2.2/src/compiler/transformers/es2015.ts#L1082-L1098
      *
      * Additionally, we handle synthetic delegate constructors that are emitted when TypeScript
      * downlevel's ES2015 synthetically generated to ES5. These vary slightly from the default
      * structure mentioned above because the ES2015 output uses a spread operator, for delegating
      * to the parent constructor, that is preserved through a TypeScript helper in ES5. e.g.
      *
      * ```
      * return _super.apply(this, tslib.__spread(arguments)) || this;
      * ```
      *
      * or, since TypeScript 4.2 it would be
      *
      * ```
      * return _super.apply(this, tslib.__spreadArray([], tslib.__read(arguments))) || this;
      * ```
      *
      * Such constructs can be still considered as synthetic delegate constructors as they are
      * the product of a common TypeScript to ES5 synthetic constructor, just being downleveled
      * to ES5 using `tsc`. See: https://github.com/angular/angular/issues/38453.
      *
      *
      * @param constructor a constructor function to test
      * @returns true if the constructor appears to have been synthesized
      */
    /* private */ var isSynthesizedConstructor: Any = js.native
    
    /**
      * Identifies synthesized super calls which pass-through function arguments directly. The
      * synthetic delegate super call match the following patterns we intend to match:
      *
      * 1. Delegate call emitted by TypeScript when it emits ES5 directly.
      *   ```
      *   _super !== null && _super.apply(this, arguments) || this;
      *   ```
      *
      * 2. Delegate call emitted by TypeScript when it downlevel's ES2015 to ES5.
      *   ```
      *   _super.apply(this, tslib.__spread(arguments)) || this;
      *   ```
      *   or using the syntax emitted since TypeScript 4.2:
      *   ```
      *   return _super.apply(this, tslib.__spreadArray([], tslib.__read(arguments))) || this;
      *   ```
      *
      * @param expression an expression that may represent a default super call
      * @returns true if the expression corresponds with the above form
      */
    /* private */ var isSynthesizedDefaultSuperCall: Any = js.native
    
    /**
      * Identifies synthesized super calls which pass-through function arguments directly and
      * are being returned. The following patterns correspond to synthetic super return calls:
      *
      * 1. Delegate call emitted by TypeScript when it emits ES5 directly.
      *   ```
      *   return _super !== null && _super.apply(this, arguments) || this;
      *   ```
      *
      * 2. Delegate call emitted by TypeScript when it downlevel's ES2015 to ES5.
      *   ```
      *   return _super.apply(this, tslib.__spread(arguments)) || this;
      *   ```
      *   or using the syntax emitted since TypeScript 4.2:
      *   ```
      *   return _super.apply(this, tslib.__spreadArray([], tslib.__read(arguments))) || this;
      *   ```
      *
      * @param statement a statement that may be a synthesized super call
      * @returns true if the statement looks like a synthesized super call
      */
    /* private */ var isSynthesizedSuperReturnStatement: Any = js.native
    
    /**
      * Identifies synthesized super calls which pass-through function arguments directly and are
      * being assigned to a common `_this` variable. The following patterns we intend to match:
      *
      * 1. Delegate call emitted by TypeScript when it emits ES5 directly.
      *   ```
      *   var _this = _super !== null && _super.apply(this, arguments) || this;
      *   ```
      *
      * 2. Delegate call emitted by TypeScript when it downlevel's ES2015 to ES5.
      *   ```
      *   var _this = _super.apply(this, tslib.__spread(arguments)) || this;
      *   ```
      *   or using the syntax emitted since TypeScript 4.2:
      *   ```
      *   return _super.apply(this, tslib.__spreadArray([], tslib.__read(arguments))) || this;
      *   ```
      *
      * @param statement a statement that may be a synthesized super call
      * @returns true if the statement looks like a synthesized super call
      */
    /* private */ var isSynthesizedSuperThisAssignment: Any = js.native
  }
}
